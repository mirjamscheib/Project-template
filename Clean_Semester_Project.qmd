---
title: "Semester_Project"
format: html
---

# Introduction 
It is known that several factors influence spatio-temporal movement of people. Like weather (Quelle), day of the week (quelle) and time of the day (quelle). 

# Pre-Processing 
•	Daten anreichern: 
    	Oder einfach mit Segmenten arbeiten? Sessile and moving unterscheiden?


## - Packages 
```{r}
# clear space 
rm(list=ls())

# load packages 
library("readr")
library("dplyr")
library("ggplot2")
library("sf")
library("terra")
library("tmap")
library("gitcreds")
library("dplyr")
library("SimilarityMeasures")
library("lubridate")
library("plotly")

```

## - Load Data 
we exclude gps data, because of the inherent different nature of data structure of this dataset, which would make research work more complex
```{r}
# load all posmo data --------------------------------------- 
posmo1 <- read_delim("posmo_data/steinm05_posmo_2023_04_10_2023_05_15.csv")
posmo2 <- read_delim("posmo_data/scheimir_posmo_2023-01-01T00_00_00+01_00-2023-05-15T23_59_59+02_00.csv")
posmo3 <- read_delim("posmo_data/a77bd18b-2615-4b03-802b-879bf3c93798_2023-01-01T00-00-00_2023-05-13T23-59-59.csv")
posmo4 <- read_delim("posmo_data/posmo - BuJa.csv") # nur bike data 
posmo5 <- read_delim("posmo_data/posmo_1.csv")
posmo6 <- read_delim("posmo_data/posmo_2.csv")
posmo7 <- read_delim("posmo_data/posmo_3.csv")
posmo8 <- read_delim("posmo_data/74137c1d0f374561eb733f3da00d0d3b0e01ad0edf7e441c9ea647ce3e44997d.csv")
posmo9 <- read_delim("posmo_data/Naladata.csv")
posmo10 <- read_delim("posmo_data/posmo_e3.csv")
posmo11 <- read_delim("posmo_data/posmo_validated_data_20230608.csv")
```

## - Filter data/ create workable dataframe
```{r}
# name users for easier data handling 
posmo1 <- posmo1 |>  
  mutate(dataset = "posmo1")

posmo2 <- posmo2 |>  
  mutate(dataset = "posmo2")

posmo3 <- posmo3 |>  
  mutate(dataset = "posmo3")

posmo4 <- posmo4 |>  
   mutate(dataset = "posmo4")

posmo5 <- posmo5 |>  
  mutate(dataset = "posmo5")

posmo6 <- posmo6 |>  
  mutate(dataset = "posmo6")

posmo7 <- posmo7 |>  
  mutate(dataset = "posmo7")

posmo8 <- posmo8 |>  
  mutate(dataset = "posmo8")

posmo9 <- posmo9 |>  
  mutate(dataset = "posmo9")

posmo10 <- posmo10 |>  
  mutate(dataset = "posmo10")

posmo11 <- posmo11 |>  
  mutate(dataset = "posmo11")

# bind all data together, create a single dataframe 
posmo <- rbind(posmo1, posmo2, posmo3, posmo4, posmo5, posmo6, posmo7, posmo8, posmo9, posmo10, posmo11)

# Exclude rows with missing values using complete.cases() because transforming into sf object does not work, when we have missing values in coordinate columns
posmo <- posmo[complete.cases(posmo$lon_x), ]

# transform posmo data into an sf object 
posmo <- st_as_sf(posmo, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

# look at data consistency
ggplot(posmo, aes(datetime, dataset))+
         geom_point()

# exclude posmo7, posmo4, posmo10 due to insufficient time overlap with the other datasets
# additionally remove user_id and place_name column, because the column dataset has unique/simple names for every user 
posmo <- posmo |>
  subset(dataset != "posmo4" & dataset != "posmo7" & dataset != "posmo10" & dataset != "posmo9" & dataset != "posmo8") |>
  select(-user_id, -place_name)

# control if posmo4 is removed 
posmo$dataset |> 
  unique()
# -> posmo4, posmo7 and posmo10 successfully removed

# transform datetime into POSIXct format 
posmo <- posmo |>
  mutate(datetime = as.POSIXct(datetime))
```

### - Cut Dataset in Time
```{r}
# plot data without outliers to set timespan for further analysis
ggplot(posmo, aes(datetime, dataset))+
         geom_point()

# choose timespan in which the most overlap of measurements between users is 
posmo <- posmo |>
  filter(datetime >= "2023-04-28 00:00:00", 
         datetime < "2023-05-09 00:00:00")           

# look at the new timecut data - more consistent 
ggplot(posmo, aes(datetime, dataset))+
         geom_point()
```

### - Remove outliers 
```{r}
# delete trajectory data outside of switzerland (= delete outliers; norway & france): look at single posmo data to determine outliers 
tmap_mode("view")

# outlier - norway & france 
tm_shape(posmo) +
  tm_dots()

# load swiss boundary for intersection 
swiss <- read_sf("data/schweiz.gpkg")

# intersect posmo data with swiss boarder
posmo_cut <- st_intersection(posmo, swiss)

# remove transport_mode "Airplane" because it is part of the outliers 
posmo_cut <- posmo_cut |>
  subset(transport_mode != "Airplane")

# control if outliers are removed 
tm_shape(posmo_cut) +
 tm_dots()

# save cleaned dataset in an .gpkg file to shorten calculation time for subsequent analysing steps 
st_write(posmo_cut, "posmo_data/posmo_cut.gpkg")
```


## - Add convenience variables 
### - day/night, weekend/weekday
```{r}
# load outlier free data for shorter calculation time 
posmo <- read_sf("posmo_data/posmo_cut.gpkg")

# Add convenience variable weekend vs. workday (Sa-So: Weekend, Mo-Fr: Workday) 
posmo <- posmo |>
  mutate(day_week = ifelse(weekday %in% c("Sat", "Sun"), "weekend", "weekday"))

# Add concenience variables day vs. night (Day: 06:00 – 22:00, Night: 22:00 – 06:00) 
# Define the start and end time ranges
start_time <- as.POSIXct("06:00:00", format = "%H:%M:%S", tz = "UTC")
end_time <- as.POSIXct("22:00:00", format = "%H:%M:%S", tz = "UTC")

# Extract only the time component
start_time <- format(start_time, format = "%H:%M:%S")
end_time <- format(end_time, format = "%H:%M:%S")

# create convenience variables day vs. night
posmo <- posmo |>
  mutate(time = format(datetime, format = "%H:%M:%S", tz = "UTC"), # Add convenience variable with only time 
         day_night = ifelse(time >= start_time & time <= end_time, "night", "day"))


# proof if convenience variables worked 
unique(posmo$day_night)
unique(posmo$day_week)

# add convenience variable with date only (without time) and remove columns which are not used
posmo <- posmo |> 
  mutate(date = lubridate::date(datetime)) |>
  select(-ICC, -NAME)
```

### OK - rain/no rain 
Meaning of the columns in weather: 
- tre200s0 = Air temperature 2 m above ground (momentary value in °C)
- rco150z0 = Precipitation duration in ten-minute sum 
- sre00z0 = Sunshine duration ten-minute sum

```{r}
# load all weather data 
legend <- read_delim("data/weather_legend.csv")
weather_raw <- read_delim("data/weather_measurements.csv") 

# join weather and legend data together
weather <- left_join(weather_raw, legend, by = "stn")

# create sf object of joined data
weather <- st_as_sf(weather, coords = c("E","N"), crs = 2056)

# look at spatial distribution of weather stations 
tm_shape(weather) +
  tm_dots()

# create a new column with a rounded Datetime for the posmo data, to create a time join key with the weather data 
posmo <- posmo |>
  mutate(
    Datetime_round = lubridate::round_date(datetime, "10 minutes")
    )

# create an sf object for legend to calculate nearest stations
legend_sf <- st_as_sf(legend, coords = c("E","N"), crs = 2056) 

# calculate nearest weather stations from every point of trajectory
posmo$stn <- legend_sf$stn[st_nearest_feature(posmo, legend_sf)]

# select only rain data, time and station names from weather 
weather_posmo <- st_drop_geometry(weather) |> 
  select(rco150z0, time, stn) 

# join rain and station name information for every trajectory point which is the nearest to the calculated stations 
posmo_added <- left_join(posmo, weather_posmo, by = c("stn" = "stn", "Datetime_round" = "time"))

# create convenience variable with rain/no rain for every entry 
posmo_added <- posmo_added |>
  mutate(rain = ifelse(rco150z0.y %in% c(0, NA), "no_rain", "rain"))
```

### calculate rain per day
```{r}
# calculate rainy, not rainy days 
posmo <- posmo_added |>
  group_by(date) |>
  mutate(sum_rain = sum(rco150z0.y, na.rm = TRUE),
         rain_day = ifelse(sum_rain < 85, "no_rain", "rain")) # hier noch threshold festlegen 
#  group_by(date, sum_rain, transport_mode)
```


```{r}
# write function to calculate steplength, timelag and speed 
metrics <- function(a, x, y, z) {
  mutate(a, steplength_m = sqrt((x - lead(x))^2 + (y - lead(y))^2),
           timelag = as.numeric(difftime(lead(z), z, units = "secs")),
           speed = steplength_m/timelag)
}

# seperate coordinates in two different columns for subsequent analysis steps
posmo_coordinates <- st_coordinates(posmo)

# add the separated coordinates to the posmo variable 
posmo_sep <- cbind(posmo, posmo_coordinates)

metrics(a = posmo_sep, x = X, y = Y, z = datetime)
  
posmo |> 
  group_by(rain_day, date, dataset, transport_mode) |> 
  metrics(x = X, y = Y, z = datetime)

posmo |> 
  group_by(rain_day, date, dataset, transport_mode) |> 
    mutate(steplength_m = sqrt((X - lead(X))^2 + (Y - lead(Y))^2),
           timelag = as.numeric(difftime(lead(datetime), datetime, units = "secs")),
           speed = steplength_m/timelag)
 
  group_by(rain_day, date, dataset, transport_mode) |> 
  # summarise(travldis_day = mean(steplength_m, na.rm = T),
    #        speed_mean = mean(speed, na.rm = T)) # mean brauchen wir nicht unbedingt

# nicht über mean darstellen 
ggplot(mean_rain, aes(transport_mode, log(travldis_day), fill = rain_day)) +
  geom_boxplot()

ggplot(mean_rain, aes(rain_day, log(travldis_day), col = transport_mode)) +
  geom_boxplot()
```

### Save cleaned, added dataset
```{r}
# save clean data in dataframe as .gpkg
st_write(posmo_added, "posmo_data/posmo_clean.gpkg")
```


# Research Questions 
## Question 1: Miriam 
Does the day of the week (weekend vs. workday) have an impact on spatio-temporal movement patterns?

Calculate timelag, steplength and speed for posmo 

- spatial: movement pattern -> mean trip duration/distance per weekday/workday - DONE
- temporal: mean distance per weekend-day or workday-day -  DONE
### Load cleaned data
```{r}
# load clean data 
posmo <- read_sf("posmo_data/posmo_clean.gpkg")
```

Calculate timelag, steplength and speed for posmo -> temporal

In general first:
```{r}
# seperate coordinates in two different columns for subsequent analysis steps
posmo_coordinates <- st_coordinates(posmo_added)

# add the separated coordinates to the posmo variable 
posmo_sep <- cbind(posmo_added, posmo_coordinates)

# timelag in s = diff_s
# compare weekend/ weekday
ggplot(posmo, aes(transport_mode, log(travldis_day), fill = day_week)) +
  geom_boxplot()

#Steplength per day
mean_stepl_per_weekday <- posmo_sep |>  
  group_by(weekday, dataset) |> 
  summarise(mean(steplength_m, na.rm = T))

#But we want mean of travelling distance per weekday... 
mean_travldis_per_date <- posmo |>  
  group_by(weekday, date, dataset) |> 
  summarise(travldis_day = mean(steplength_m, na.rm = T)) #da ging was in die Hose, irgendwie ist jeder zweite Eintrag 0 und für einen Wochentag gibt es zwei Daten nacheinander, das macht kein Sinn, aber ich glaube es stimmt trotzdem noch.. 

mean_travldis_per_weekday <- mean_travldis_per_date |> 
  group_by(weekday, dataset) |> 
  summarise(travldis_weekday = mean(travldis_day))
#was auch immer die Geometry noch da macht..  

# visualize mean travelled distance per date
ggplot() +
  geom_boxplot(data = mean_travldis_per_date, aes(dataset, log(travldis_day)), notch = T) +
  labs(title = "mean travelled distance per date")


#Speed
posmo <- posmo |> 
  mutate(speed_ms = steplength_m/diff_s)

#Check out histogram for speed frequencies
hist(log10(posmo$speed_ms), 100)

#Steplength WEEKDAY Influence -------------------------------------
#But we want mean of travelling distance per weekday... 
mean_travldis_per_date_week <- posmo |> 
  mutate(steplength_m = sqrt((X - lead(X))^2 + (Y - lead(Y))^2))|>  
  group_by(day_week, date, dataset) |> 
  summarise(travldis_day = mean(steplength_m, na.rm = T))

# visualize mean travelled distance compared between weekend/weekday
ggplot() +
  geom_boxplot(data = mean_travldis_per_date_week, aes(day_week, log(travldis_day))) +
  labs(title = "Travelled distance compared between weekend/weekday")

```

Same for posmo subset of "walk"
```{r}
#Timelag 
posmo_walk <- posmo_walk |> 
  mutate(diff_s = as.integer(difftime(lead(datetime), datetime, units == "secs")))
#es gibt diff_s mit 0, die muss man glaube ich entfernen, kann es sein das Posmo z.T. doppelte Einträge erfasst hat?

#Steplength
posmo_walk <- posmo_walk |> 
  mutate(steplength_m = sqrt((X - lead(X))^2 + (Y - lead(Y))^2))

#Steplength per day
mean_stepl_per_weekday <- posmo_walk |>  
  group_by(weekday) |> 
  summarise(mean(steplength_m, na.rm = T))

#But we want mean of travelling distance per weekday... 
mean_travldis_per_date <- posmo_walk |>  
  group_by(weekday, date) |> 
  summarise(travldis_day = mean(steplength_m, na.rm = T)) #da ging was in die Hose, irgendwie ist jeder zweite Eintrag 0 und für einen Wochentag gibt es zwei Daten nacheinander, das macht kein Sinn, aber ich glaube es stimmt trotzdem noch.. 

mean_travldis_per_weekday <- mean_travldis_per_date |> 
  group_by(weekday) |> 
  summarise(travldis_weekday = mean(travldis_day))
 
#die Distanzen pro Tag sind sehr hoch, das finde ich speziell.. stimmt das wirklich? Liegt es daran, dass wir nur wenige Personen haben? Gab es viele Fehlerfassungen der App? 
```

SPATIAL: movement pattern -> mean duration per weekday/workday
```{r}
### Calculate temporal windows ------------------------------------------------------
# calculates time taken from each step to the next 
# n_plus2 calculates an offset of 2 time steps
posmo <- posmo |>
  mutate(
    n_plus1 = sqrt((lead(X) - X)^2 + (lead(Y) - Y)^2), # distance to pos + 10 seconds
    n_plus2 = sqrt((lead(X, 2) - X)^2 + (lead(Y, 2) - Y)^2), # distance to pos +20 seconds
    n_minus1 = sqrt((lag(X) - X)^2 + (lag(Y) - Y)^2), # distance to pos -10 seconds
    n_minus2 = sqrt((lag(X, 2) - X)^2 + (lag(Y, 2) - Y)^2) # distance to pos -20 seconds
  )

# ungroup() because when we apply rowwise() each row is a grouped individually which we don't want. 
posmo <- posmo |>
  rowwise()|>
  mutate(
    stepMean = mean(c(n_minus1, n_minus2, n_plus1, n_plus2))
  ) |>
  ungroup()
```

Define static, than remove "static point"
```{r}
posmo <- posmo |>
    ungroup() |>
    mutate(static = stepMean < mean(stepMean, na.rm = TRUE))

posmo_nostatic <- posmo |>
    filter(!static)

posmo_nostatic |>
    ggplot(aes(X, Y)) +
    geom_path() +
    geom_point() +
    coord_fixed() +
    theme(legend.position = "bottom")

tmap_mode("view")

tm_shape(posmo_nostatic) +
  tm_dots()

```

Segment-based analysis
Asign segmet IDs and use them to remove short segments and calculate segment (trip) duration
```{r}
rle_id <- function(vec) {
    x <- rle(vec)$lengths
    as.factor(rep(seq_along(x), times = x))
}

posmo <- posmo |>
    mutate(segment_id = rle_id(static))

head(posmo)
unique(posmo$segment_id) #wie erwartet haben wir uuunzählige Segmente

```

For mean duration of trips per weekday/weekend-day remove static segments and segments with duration < 10 min
```{r}
#only movement segments
posmo_trips <- posmo |>
    filter(!static)
    
#calculate trip duration and trip distance
posmo_trips <- posmo_trips |>
  group_by(segment_id) |> 
  mutate(trip_duration = sum(diff_s), trip_dis = sum(steplength_m))

#remove trips that are shorter than 10min = 600s
posmo_trips <- posmo_trips |>
  subset(trip_duration > 600)

```

Calculate mean duration and mean dis of trips per day
```{r}
#mean trip duration looks odd, need to check that (!!)
posmo_trips |>
  group_by(segment_id) |>
  ggplot() +
  geom_boxplot(aes(day_week, log(trip_duration/60))) +
  labs(title = "mean trip duration [min] compared between weekend/weekday")
  
```


```{r}
#mean trip distance compared between weekend/weekday seems OK
posmo_trips |>
  group_by(segment_id) |>
  ggplot() +
  geom_boxplot(aes(day_week, trip_dis)) +
  labs(title = "mean trip distance compared between weekend/weekday")
  
```

Mean trip distance per hour of the day
```{r} 
posmo_hours <- posmo_trips |>
  mutate(Datetime_round = lubridate::round_date(datetime, "1h")) |>
  mutate(time_round = format(Datetime_round, format = "%H", tz = "UTC")) # Add convenience variable with only time 


posmo_hours |>
  group_by(segment_id) |>
  ggplot() +
  geom_boxplot(aes(time_round, log(trip_dis))) +
  labs(title = "mean trip distance per hour of the day")

#Wir haben zu wenig Daten für so einen Plot scheint es, die Boxplots sehen nicht so "gesund" aus
```

```{r}
posmo_hours |>
  group_by(segment_id) |>
  ggplot() +
  geom_boxplot(aes(time_round, trip_dis)) +
  coord_polar("x") +
  labs(title = "mean trip distance per hour of the day")

#Tja, da niemand in der Nacht nur einmal unterwegs war, haben wir ab 21Uhr bis 04 Uhr Morgens absolut keine Daten...

```

## Question 2: Miriam
Durchschnittliche Reisestrecke pro Tageszeit, gibt es Tageszeiten zu denen man eher längere/kürzere Strecken reist?  
Durchschnittliche Anzahl Reisen pro Tag? 

```{r}
posmo_hours |>
  group_by(segment_id) |>
  ggplot() +
  geom_bar(aes(trip_dis, colour = time_round)) +
  labs(title = "mean trip distance per hour of the day")
```



Lineplot with hours and weekdays, number of trips
```{r}
posmo_hours |>
  group_by(segment_id) |>
  ggplot() +
  geom_line(aes(time_round, trip_dis, colour = weekday)) +
  labs(title = "mean trip distance per hour of the day")

```

Average number of trips per day
```{r}
posmo_hoursx <- posmo_hours |>
  mutate(segment_name = as.character(segment_id)) |> 
  group_by(date, segment_name) |>
  add_count(segment_name)


#num_trips = Anzahl verschiedener segment_ids  pro date
#funktionier aber nicht mit einem Factor, es zählt nicht die Anzahl verschiedenen Factors pro Tag...
?count()

View(posmo_hoursx)

```

Same with mean travel distance (not trip distance) per hours
```{r}
mean_travldis_per_hour <- posmo_hours |> 
  mutate(steplength_m = sqrt((X - lead(X))^2 + (Y - lead(Y))^2))|>  
  group_by(day_week, time_round, weekday) |> 
  summarise(travldis_hour = mean(steplength_m, na.rm = T))



mean_travldis_per_hour |>
  ggplot() +
  geom_boxplot(aes(time_round, travldis_hour, colour = weekday)) +
  labs(title = "mean distance per hour of the day")

#Ich verstehe nicht, was ich da machen muss, dass ich so einen tollen Linienplot erhalte... die Boxplots müssten ja nurnoch mit Linien verbunden sein, aber so eine Funktion gibt es irgendwie nicht
```



Ansatz von Mirj:

- gleicher Plot wie im Best practice example: linienplot mit weekdays (pro weekday 1 linie)
```{r}
# Habe hier schon mal versucht den Plot vom Best Practice example zu erstellen 
# Geht wohl doch nicht so einfach. Meine Vorgehensweise: ich wollte die mittlere Distanz pro stunde am Tag und wochentag ausrechnen damit dann für alle user jeweils der durchschnitt berechnet wird wie gross die tavel-distance zu einer bestimmten stunde ist 
# round datetime to 1h 
posmo_round <- posmo |>
  mutate(Datetime_round = lubridate::round_date(datetime, "1h")) |>
  mutate(time_round = format(Datetime_round, format = "%H", tz = "UTC")) # Add convenience variable with only time 


# ich glaube hier liegt wahrsch der Fehler. Der Datensatz den wir brauchen um den Linienplot zu machen bräuchte folgendes: Für jede volle Stunde für einen ganzen Tag, also 24h (z.B. 8 Uhr, 10 Uhr etc.) muss ein Wert der mittleren Traveldistanz für jeden Wochentag vorliegen. 
# Bsp. für 10 Uhr haben wir dann 5 Einträge (für Mo-Fr je einen) und so weiter für jede Stunde

# Ich habe das Gefühl irgendwie der Datensatz stimmt eig. schon aber checke nicht woran es liegt
posmo_test <- posmo_round |>
  group_by(time_round, weekday) |>
  mutate(steplength = sqrt((X-lead(X))^2+(Y-lead(Y))^2)) |>
  summarise(mean_dis = mean(steplength, na.rm = TRUE))


# im plot sieht es dann aber eben nicht so aus... und ich weiss nicht genau woran es liegt
ggplot(posmo_test, aes(time_round, log(mean_dis), col = weekday)) +
  geom_point()+
  geom_line()

#Wieso funktioniert geom_line nicht? Im Internet steht der Code genauso und es gibt eine Line... 
```


## Question 3: Mirjam 
Does the weather condition (e.g. rain, sunshine) impact spatio-temporal patterns of students by foot and/or bicycle?
- spatial: movement pattern (duration, distance, velocity)
- temporal: mean distance per weekend-day or workday-day

Outputs:
Boxplot duration, distance, velocity for rain/ no rain
Convex Hull per user 

### Temporal Analysis 
```{r}
# load clean data 
posmo <- read_sf("posmo_data/posmo_clean.gpkg")

# we need the coordinates in separates columns to calculate eucl. distance
posmo_coordinates <- st_coordinates(posmo)

# add the separated coordinates to the posmo variable 
posmo <- cbind(posmo, posmo_coordinates)

# 1. calculate mean travelling distance, duration and velocity for rain and no rain by foot 
# subset foot and only day data 
mean_rain_foot <- posmo_rain |> 
  subset(transport_mode == c("Walk", "Run") &
         day_night == "day") |>
  group_by(rain, date, dataset) |> 
    mutate(steplength_m = sqrt((X - lead(X))^2 + (Y - lead(Y))^2),
           timelag = as.numeric(difftime(lead(datetime), datetime, units =
                                           "secs")),
           speed = steplength_m/timelag) |> 
  summarise(travldis_day = mean(steplength_m, na.rm = T),
            speed_mean = mean(speed, na.rm = T))


# 2. calculate mean travelling distance, duration and velocity for rain and no rain by bike
# subset foot and only day data 
mean_rain_bike <- posmo |> 
  subset(transport_mode == c("Bike") & 
           day_night == "day") |>
  group_by(rain, date, dataset) |> 
  mutate(steplength_m = sqrt((X - lead(X))^2 + (Y - lead(Y))^2),
           timelag = as.numeric(difftime(lead(datetime), datetime, units =
                                           "secs")),
           speed = steplength_m/timelag) |>
  subset(!is.infinite(speed)) |>
  summarise(travldis_day = mean(steplength_m, na.rm = T),
            speed_mean = mean(speed, na.rm = T))

# 3. visualise mean travelling distance for rain and no rain by foot
ggplot() +
  geom_boxplot(data = mean_rain_foot, aes(rain, travldis_day)) +
  labs(title = "mean travelled distance compared between rain/no rain by foot") 

# 4. visualise mean travelling distance for rain and no rain by bike
# outliers up to 6000 m 
ggplot() +
  geom_boxplot(data = mean_rain_bike, aes(rain, travldis_day)) +
  labs(title = "mean travelled distance compared between rain/no rain by bike") 
```

1. Was heisst Regen (moving window) (regentag, nicht regentag)
2. Unterscheiden zwischen regentaugliche, regenuntaugliche Transport modes (Fragestellung anpassen zu regentauglich, nicht regentauglich)
3. wie viel km ich pro tag mit welchem transportmittel gefahren bin (boxplot)
4. Zeitschnitt macht doch Sinn wenn es geht 

```{r}
# Mittlere Distanz ÖV/Auto -------------------------------------------------
# 9. isolate all rows with travelmode "car", "train" ----------------------------------
posmo_car_train <- posmo |>
  subset(transport_mode == c("Train", "Tram", "Car", "Bus"))#works!
```


### Spatial Analysis 
```{r}
# 1. Visualise mean speed between rain/ no rain by foot 
ggplot() +
  geom_boxplot(data = mean_rain_foot, aes(rain, speed_mean)) +
  labs(title = "mean speed compared between rain/no rain by foot") 

# 2. Visualise mean speed between rain/ no rain by bike 
ggplot() +
  geom_boxplot(data = mean_rain_bike, aes(rain, speed_mean)) +
  labs(title = "mean speed compared between rain/no rain by bike") 
```

### Test Question 3
```{r}
# round datetime to 1h 
library(lubridate)
posmo_round <- posmo |>
  mutate(hour = lubridate::hour(datetime))




posmo_test <- posmo_round |>
  group_by(hour, weekday, day_week) |>
  mutate(steplength = sqrt((X-lead(X))^2+(Y-lead(Y))^2)) |>
  summarise(mean_dis = mean(steplength, na.rm = TRUE))


# mo-so
ggplot(posmo_test, aes(hour, log(mean_dis), col = weekday)) +
  geom_point() +
  geom_line()

# weekend vs. weekday
ggplot(posmo_test, aes(hour, log(mean_dis), col = day_week)) +
  geom_point() +
  geom_line()

# jetzt das noch mit segmentierten Daten 
```


# Visualisations 
Wettefrage: 
Boxplot Vergleich rain / no rain (x travelmode, y (spatial) distance, (spatial) velocity, (temporal) duration, färbung rain no rain)

Evt. map plot - rain no rain, convex hull 
Table Summary like best practice example 

Weekend/Weekday Frage:
Boxplot Vergleich weekend, weekday (x: travelmode, y: (spatial) distance, (spatial) velocity, (temporal) duration, färbung: weekend/weekday)

Evt. map plot - weekend/weekday, convex hull 
Table Summary like best practice example 

Distance per hour of the day: 
X-y plot Linienplot (x: hours, y: distance, trip (segment), färbung: Wochentag, Weekend/Weekday)

Table Summary like best practice example 

Evt. map plot - weekend/weekday, convex hull 


# Project Text 
1. Zeichenzählung einfügen 
2. Paper in Vorlesungsfolien (Zotero zitieren in Word)


