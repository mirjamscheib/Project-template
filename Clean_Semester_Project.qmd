---
title: "Semester_Project"
format: html
---

# Introduction 
It is known that several factors influence spatio-temporal movement of people. Like weather (Quelle), day of the week (quelle) and time of the day (quelle). 

# Pre-Processing 
## - Packages 
```{r}
# clear space 
rm(list=ls())

# load packages 
library("readr")
library("dplyr")
library("ggplot2")
library("sf")
library("terra")
library("tmap")
library("gitcreds")
library("dplyr")
library("SimilarityMeasures")
library("lubridate")
library("plotly")

```

## - Load Data 
we exclude gps data, because of the inherent different nature of data structure of this dataset, which would make research work more complex
```{r}
# load all posmo data --------------------------------------- 
posmo1 <- read_delim("posmo_data/steinm05_posmo_2023_04_10_2023_05_15.csv")
posmo2 <- read_delim("posmo_data/scheimir_posmo_2023-01-01T00_00_00+01_00-2023-05-15T23_59_59+02_00.csv")
posmo3 <- read_delim("posmo_data/a77bd18b-2615-4b03-802b-879bf3c93798_2023-01-01T00-00-00_2023-05-13T23-59-59.csv")
posmo4 <- read_delim("posmo_data/posmo - BuJa.csv") # nur bike data 
posmo5 <- read_delim("posmo_data/posmo_1.csv")
posmo6 <- read_delim("posmo_data/posmo_2.csv")
posmo7 <- read_delim("posmo_data/posmo_3.csv")
posmo8 <- read_delim("posmo_data/74137c1d0f374561eb733f3da00d0d3b0e01ad0edf7e441c9ea647ce3e44997d.csv")
posmo9 <- read_delim("posmo_data/Naladata.csv")
posmo10 <- read_delim("posmo_data/posmo_e3.csv")
posmo11 <- read_delim("posmo_data/posmo_validated_data_20230608.csv")
```

## - Filter data/ create workable dataframe
```{r}
# name users for easier data handling 
posmo1 <- posmo1 |>  
  mutate(dataset = "posmo1")

posmo2 <- posmo2 |>  
  mutate(dataset = "posmo2")

posmo3 <- posmo3 |>  
  mutate(dataset = "posmo3")

posmo4 <- posmo4 |>  
   mutate(dataset = "posmo4")

posmo5 <- posmo5 |>  
  mutate(dataset = "posmo5")

posmo6 <- posmo6 |>  
  mutate(dataset = "posmo6")

posmo7 <- posmo7 |>  
  mutate(dataset = "posmo7")

posmo8 <- posmo8 |>  
  mutate(dataset = "posmo8")

posmo9 <- posmo9 |>  
  mutate(dataset = "posmo9")

posmo10 <- posmo10 |>  
  mutate(dataset = "posmo10")

posmo11 <- posmo11 |>  
  mutate(dataset = "posmo11")

# bind all data together, create a single dataframe 
posmo <- rbind(posmo1, posmo2, posmo3, posmo4, posmo5, posmo6, posmo7, posmo8, posmo9, posmo10, posmo11)

# Exclude rows with missing values using complete.cases() because transforming into sf object does not work, when we have missing values in coordinate columns
posmo <- posmo[complete.cases(posmo$lon_x), ]

# transform posmo data into an sf object 
posmo <- st_as_sf(posmo, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

# transform datetime into POSIXct format 
posmo <- posmo |>
  mutate(datetime = as.POSIXct(datetime))
```

### - Cut Dataset in Time
```{r}
# look at data consistency
ggplot(posmo, aes(datetime, dataset))+
         geom_point()

# exclude posmo7, posmo4, posmo10 due to insufficient time overlap with the other datasets
# additionally remove user_id and place_name column, because the column dataset has unique/simple names for every user 
posmo <- posmo |>
  subset(dataset != "posmo4" & dataset != "posmo7" & dataset != "posmo10" & dataset != "posmo9" & dataset != "posmo8") |>
  select(-user_id, -place_name)

# control if posmo4 is removed 
posmo$dataset |> 
  unique()
# -> posmo4, posmo7 and posmo10 successfully removed

# plot data without outliers to set timespan for further analysis
ggplot(posmo, aes(datetime, dataset))+
         geom_point()

# choose timespan in which the most overlap of measurements between users is 
posmo <- posmo |>
  filter(datetime >= "2023-04-28 00:00:00", 
         datetime < "2023-05-09 00:00:00")           

# look at the new timecut data - more consistent 
ggplot(posmo, aes(datetime, dataset))+
         geom_point()
```

### - Remove outliers 
```{r}
# delete trajectory data outside of switzerland (= delete outliers; norway & france): look at single posmo data to determine outliers 
tmap_mode("view")

# outlier - norway & france 
tm_shape(posmo) +
  tm_dots()

# load swiss boundary for intersection 
swiss <- read_sf("data/schweiz.gpkg")

# intersect posmo data with swiss boarder
posmo_cut <- st_intersection(posmo, swiss)

# remove transport_mode "Airplane" because it is part of the outliers 
posmo_cut <- posmo_cut |>
  subset(transport_mode != "Airplane")

# control if outliers are removed 
tm_shape(posmo_cut) +
 tm_dots()

# save cleaned dataset in an .gpkg file to shorten calculation time for subsequent analysing steps 
st_write(posmo_cut, "posmo_data/posmo_cut.gpkg")
```


## - Add convenience variables 
### - day/night, weekend/weekday
```{r}
# load outlier free data for shorter calculation time 
posmo <- read_sf("posmo_data/posmo_cut.gpkg")

# Add convenience variable weekend vs. workday (Sa-So: Weekend, Mo-Fr: Workday) 
posmo <- posmo |>
  mutate(day_week = ifelse(weekday %in% c("Sat", "Sun"), "weekend", "weekday"))

# Add concenience variables day vs. night (Day: 06:00 – 22:00, Night: 22:00 – 06:00) 
# Define the start and end time ranges
start_time <- as.POSIXct("06:00:00", format = "%H:%M:%S", tz = "UTC")
end_time <- as.POSIXct("22:00:00", format = "%H:%M:%S", tz = "UTC")

# Extract only the time component
start_time <- format(start_time, format = "%H:%M:%S")
end_time <- format(end_time, format = "%H:%M:%S")

# create convenience variables day vs. night
posmo <- posmo |>
  mutate(time = format(datetime, format = "%H:%M:%S", tz = "UTC"), # Add convenience variable with only time 
         day_night = ifelse(time >= start_time & time <= end_time, "night", "day"))


# proof if convenience variables worked 
unique(posmo$day_night)
unique(posmo$day_week)

# add convenience variable with date only (without time) and remove columns which are not used
posmo <- posmo |> 
  mutate(date = lubridate::date(datetime)) |>
  select(-ICC, -NAME)
```

### - rain/no rain 
Meaning of the columns in weather: 
- tre200s0 = Air temperature 2 m above ground (momentary value in °C)
- rco150z0 = Precipitation duration in ten-minute sum 
- sre00z0 = Sunshine duration ten-minute sum
```{r}
# load all weather data 
legend <- read_delim("data/weather_legend.csv")
weather_raw <- read_delim("data/weather_measurements.csv") 

# join weather and legend data together
weather <- left_join(weather_raw, legend, by = "stn")

# create sf object of joined data
weather <- st_as_sf(weather, coords = c("E","N"), crs = 2056)

# look at spatial distribution of weather stations 
#tm_shape(weather) +
# tm_dots()   # ----> dauert irgendwie total lang/geht nicht 

# create a new column with a rounded Datetime for the posmo data, to create a time join key with the weather data 
posmo <- posmo |>
  mutate(
    Datetime_round = lubridate::round_date(datetime, "10 minutes")
    )

# create an sf object for legend to calculate nearest stations
legend_sf <- st_as_sf(legend, coords = c("E","N"), crs = 2056) 

# calculate nearest weather stations from every point of trajectory
posmo$stn <- legend_sf$stn[st_nearest_feature(posmo, legend_sf)]

# select only rain data, time and station names from weather 
weather_posmo <- st_drop_geometry(weather) |> 
  select(rco150z0, time, stn) 

# join rain and station name information for every trajectory point which is the nearest to the calculated stations 
posmo_added <- left_join(posmo, weather_posmo, by = c("stn" = "stn", "Datetime_round" = "time"))

# create convenience variable with rain/no rain for every entry 
posmo_added <- posmo_added |>
  mutate(rain = ifelse(rco150z0 %in% c(0, NA), "no_rain", "rain"))
```

### - rainy / not rainy day
```{r}
# calculate rainy, not rainy days 
posmo <- posmo_added |>
  group_by(date) |>
  mutate(sum_rain = sum(rco150z0, na.rm = TRUE),
         rain_day = ifelse(sum_rain < 85, "no_rain", "rain")) # hier noch threshold festlegen 
```

## - Function to calculate metrics used 
```{r}
# write function to calculate steplength, timelag 
# function to calculate steplength
eucdist <- function(x, y) {
    steplength <- sqrt((lead(x, 2) - x)^2 + (lead(y, 2) - y)^2)
    return(steplength)
}

# function to calculate timelag
lag_time <- function(z) {
    timelag <- as.numeric(difftime(lead(z), z, units = "secs"))
    return(timelag)
}

# seperate coordinates in two different columns for subsequent analysis steps
posmo_coordinates <- st_coordinates(posmo)

# add the separated coordinates to the posmo variable 
posmo_sep <- cbind(posmo, posmo_coordinates)

# calculate timelag, steplenght and speed for the whole dataset
posmo <- posmo_sep |>
  mutate(
    timelag = lag_time(datetime),
    steplength = eucdist(X, Y),
    speed = steplength/timelag
    ) |>
  subset(!is.infinite(speed)) 
```


### - Save cleaned, added dataset
```{r}
# save clean data in dataframe as .gpkg
#st_write(posmo, "posmo_data/posmo_clean.gpkg")

# save clean data set with .csv 
write_csv(posmo, "posmo_data/posmo_clean1.csv")
```


# - Research Questions 
## - Question 1: Miriam 
Does the day of the week (weekend vs. workday) have an impact on spatio-temporal movement patterns?
### - Load cleaned data
```{r}
# load clean data 
posmo <- read_delim("posmo_data/posmo_clean1.csv")
```

### Spatial Analysis
#### - Speed & Distance
- thought: How about removing certain transport modes (funicular, horse, Other?)
```{r}
# Boxplot compare weekend/ weekday without grouping (overall steplength)
ggplot(posmo, aes(transport_mode, log(steplength), fill = day_week)) +
  geom_boxplot() +
  labs(title = "Travelled Distance per Transport Mode comparing Weekend vs. Weekday")

#die Distanzen Walk pro Tag sind sehr hoch, das finde ich speziell.. stimmt das wirklich? Liegt es daran, dass wir nur wenige Personen haben? Gab es viele Fehlerfassungen der App? 

# Boxplot compare weekend/ weekday without grouping (overall speed)
ggplot(posmo, aes(transport_mode, log(speed), fill = day_week)) +
  geom_boxplot() +
  labs(title = "Speed per Transport Mode comparing Weekend vs. Weekday")

# Table Summary 
question1_summary <- posmo |> 
  group_by(day_week, transport_mode) |> 
  summarise(steplength_mean = mean(steplength, na.rm = T),
            speed_mean = mean(speed, na.rm = T)) |> 
  mutate(percentage_steplength = steplength_mean/sum(steplength_mean)*100,
         percentage_speed = speed_mean/sum(speed_mean)*100)
```

##### not clear if to leave 
```{r}
# Barchart mean distance comparing weekend / weekday (steplength)
ggplot(question1_summary, aes(transport_mode, steplength_mean, fill = day_week)) +
  geom_bar(stat = "identity", position = "fill") +
  labs(title = "Mean travelled distance for different Travelmodes compared between Weekend vs. Weekday")

# Barchart mean velocity comparing weekend / weekday (speed)
ggplot(question1_summary, aes(transport_mode, speed_mean, fill = day_week)) +
  geom_bar(stat = "identity", position = "fill") +
  labs(title = "Mean Velocity for different Travelmodes compared between Weekend vs. Weekday")

# Barchart steplength comparing weekend / weekday (speed)
ggplot(posmo, aes(transport_mode, speed, fill = day_week)) +
  geom_bar(stat = "identity", position = "fill") +
  labs(title = "Mean Velocity for different Travelmodes compared between Weekend vs. Weekday")

# Barchart velocity comparing weekend / weekday (speed)
ggplot(posmo, aes(transport_mode, steplength, fill = day_week)) +
  geom_bar(stat = "identity", position = "fill") +
  labs(title = "Mean Velocity for different Travelmodes compared between Weekend vs. Weekday")
```

#### ! Duration 
SPATIAL: movement pattern -> mean duration per weekday/workday
```{r}
### Calculate temporal windows ------------------------------------------------------
# calculates time taken from each step to the next 
# n_plus2 calculates an offset of 2 time steps
posmo_calc <- posmo |>
  mutate(
    n_plus1 = sqrt((lead(X) - X)^2 + (lead(Y) - Y)^2), # distance to pos + 10 seconds
    n_plus2 = sqrt((lead(X, 2) - X)^2 + (lead(Y, 2) - Y)^2), # distance to pos +20 seconds
    n_minus1 = sqrt((lag(X) - X)^2 + (lag(Y) - Y)^2), # distance to pos -10 seconds
    n_minus2 = sqrt((lag(X, 2) - X)^2 + (lag(Y, 2) - Y)^2) # distance to pos -20 seconds
  )

# ungroup() because when we apply rowwise() each row is a grouped individually which we don't want. 
posmo <- posmo |>
  rowwise()|>
  mutate(
    stepMean = mean(c(n_minus1, n_minus2, n_plus1, n_plus2))
  ) |>
  ungroup()
```

Define static, than remove "static point"
```{r}
posmo <- posmo |>
    ungroup() |>
    mutate(static = stepMean < mean(stepMean, na.rm = TRUE))

posmo_nostatic <- posmo |>
    filter(!static)

posmo_nostatic |>
    ggplot(aes(X, Y)) +
    geom_path() +
    geom_point() +
    coord_fixed() +
    theme(legend.position = "bottom")

tmap_mode("view")

tm_shape(posmo_nostatic) +
  tm_dots()

```

Segment-based analysis
Asign segmet IDs and use them to remove short segments and calculate segment (trip) duration
```{r}
rle_id <- function(vec) {
    x <- rle(vec)$lengths
    as.factor(rep(seq_along(x), times = x))
}

posmo <- posmo |>
    mutate(segment_id = rle_id(static))

head(posmo)
unique(posmo$segment_id) #wie erwartet haben wir uuunzählige Segmente

```

For mean duration of trips per weekday/weekend-day remove static segments and segments with duration < 10 min
```{r}
#only movement segments
posmo_trips <- posmo |>
    filter(!static)
    
#calculate trip duration and trip distance
posmo_trips <- posmo_trips |>
  group_by(segment_id) |> 
  mutate(trip_duration = sum(diff_s), trip_dis = sum(steplength_m))

#remove trips that are shorter than 10min = 600s
posmo_trips <- posmo_trips |>
  subset(trip_duration > 600)

```

Calculate mean duration and mean dis of trips per day
```{r}
#mean trip duration looks odd, need to check that (!!)
posmo_trips |>
  group_by(segment_id) |>
  ggplot() +
  geom_boxplot(aes(day_week, log(trip_duration/60))) +
  labs(title = "mean trip duration [min] compared between weekend/weekday")
  
```


```{r}
#mean trip distance compared between weekend/weekday seems OK
posmo_trips |>
  group_by(segment_id) |>
  ggplot() +
  geom_boxplot(aes(day_week, trip_dis)) +
  labs(title = "mean trip distance compared between weekend/weekday")
  
```


### Temporal Analysis 

### Create Visual Maps 
```{r}
# transform posmo data into an sf object 
posmo <- st_as_sf(posmo, coords = c("X","Y"), crs = 2056) 

tmap_mode("view")

# unsegmented visualisation 
tm_shape(posmo) +
  tm_dots(col = "day_week")
```

```{r}
# Check out histogram for speed frequencies
hist(log10(posmo$speed), 100)
```


## - Question 2: Miriam
Durchschnittliche Reisestrecke pro Tageszeit, gibt es Tageszeiten zu denen man eher längere/kürzere Strecken reist?  
Durchschnittliche Anzahl Reisen pro Tag? 

### - Load cleaned data 
```{r}
# load clean data 
posmo <- read_delim("posmo_data/posmo_clean1.csv")
```

### Analysis
```{r}
# round datetime to 1h 
posmo_round <- posmo |>
  mutate(hour = lubridate::hour(datetime))

# create dataframe, which calculates mean steplength, speed per hour over all dates
# here with weekdays 
posmo_hour <- posmo_round |>
  group_by(hour, weekday) |>
  summarise(mean_dis = mean(steplength, na.rm = TRUE),
            mean_speed = mean(speed, na.rm = TRUE)) |> 
  mutate(percentage_dis = mean_dis/sum(mean_dis)*100,
         percentage_speed = mean_speed/sum(mean_speed)*100)

# mo-so with distance (steplength) travelled
ggplot(posmo_hour, aes(hour, log(mean_dis), col = weekday)) +
  geom_point() +
  geom_line()

# mo-so with speed 
ggplot(posmo_hour, aes(hour, log(mean_speed), col = weekday)) +
  geom_point() +
  geom_line()

# create dataframe, which calculates mean steplength, speed per hour over all dates
# here with days of the week (weekend vs. weekday)
posmo_day <- posmo_round |>
  group_by(hour, day_week)|>
  summarise(mean_dis = mean(steplength, na.rm = TRUE),
            mean_speed = mean(speed, na.rm = TRUE)) |> 
  mutate(percentage_dis = mean_dis/sum(mean_dis)*100,
         percentage_speed = mean_speed/sum(mean_speed)*100)

# weekend vs. weekday with distance (steplength) travelled
ggplot(posmo_day, aes(hour, log(mean_dis), col = day_week)) +
  geom_point() +
  geom_line()

# weekend vs. weekday with speed
ggplot(posmo_day, aes(hour, log(mean_speed), col = day_week)) +
  geom_point() +
  geom_line()

# jetzt das noch mit segmentierten Daten 
```


```{r}
posmo_hours |>
  group_by(segment_id) |>
  ggplot() +
  geom_bar(aes(trip_dis, colour = time_round)) +
  labs(title = "mean trip distance per hour of the day")
```


## - Question 3: Mirjam 
Does the weather condition (e.g. rain, sunshine) impact spatio-temporal patterns of students by foot and/or bicycle?
- spatial: movement pattern (duration, distance, velocity)
- temporal: mean distance per weekend-day or workday-day
2. Unterscheiden zwischen regentaugliche, regenuntaugliche Transport modes (Fragestellung anpassen zu regentauglich, nicht regentauglich)

Outputs:
Boxplot duration, distance, velocity for rain/ no rain
Convex Hull per user 

### - Load cleaned data 
```{r}
# load clean data 
posmo <- read_delim("posmo_data/posmo_clean1.csv")
```

### Spatial Analysis 
```{r}
# Boxplot compare weekend/ weekday without grouping (overall steplength)
ggplot(posmo, aes(transport_mode, log(steplength), fill = rain_day)) +
  geom_boxplot() +
  labs(title = "Travelled Distance per Transport Mode comparing Weekend vs. Weekday")

#die Distanzen Walk pro Tag sind sehr hoch, das finde ich speziell.. stimmt das wirklich? Liegt es daran, dass wir nur wenige Personen haben? Gab es viele Fehlerfassungen der App? 

# Boxplot compare weekend/ weekday without grouping (overall speed)
ggplot(posmo, aes(transport_mode, log(speed), fill = rain_day)) +
  geom_boxplot() +
  labs(title = "Speed per Transport Mode comparing Weekend vs. Weekday")

# Table Summary 
question2_summary <- posmo |> 
  group_by(rain_day, transport_mode) |> 
  summarise(steplength_mean = mean(steplength, na.rm = T),
            speed_mean = mean(speed, na.rm = T)) |> 
  mutate(percentage_steplength = steplength_mean/sum(steplength_mean)*100,
         percentage_speed = speed_mean/sum(speed_mean)*100)

# subset foot and only day data 
mean_rain <- posmo |> 
  subset(transport_mode == c("Walk", "Run", "Bike", "Train", "Tram", "Car", "Bus")) |>
  group_by(rain_day, date) 

# 3. visualise travelling distance for rain and no rain by foot & bike
ggplot() +
  geom_boxplot(data = mean_rain, aes(transport_mode, log(steplength), fill = rain_day)) +
  labs(title = "Travelled distance compared between rainy days vs. not rainy days by foot and bike") 

# 4. visualise speed for rain and no rain by bike & foot
ggplot() +
  geom_boxplot(data = mean_rain, aes(transport_mode, log(speed), fill = rain_day)) +
  labs(title = "Velocity compared between rainy days vs. not rainy days by foot and bike") 
```

### Temporal Analysis 

### Create Visual Maps 
```{r}
# transform posmo data into an sf object 
posmo <- st_as_sf(posmo, coords = c("X","Y"), crs = 2056) 

tmap_mode("view")

# unsegmented visualisation 
tm_shape(posmo) +
  tm_dots(col = "rain_day")
```


# Visualisations 
Wettefrage: 
Boxplot Vergleich rain / no rain (x travelmode, y (temporal) duration, färbung rain no rain)

Evt. map plot - rain no rain, convex hull 
Table Summary like best practice example 

Weekend/Weekday Frage:
Boxplot Vergleich weekend, weekday (x: travelmode, y: (spatial) distance, (spatial) velocity, (temporal) duration, färbung: weekend/weekday)

Evt. map plot - weekend/weekday, convex hull 
Table Summary like best practice example 

Distance per hour of the day: 
X-y plot Linienplot (x: hours, y: distance, trip (segment), färbung: Wochentag, Weekend/Weekday)

Table Summary like best practice example 

Evt. map plot - weekend/weekday, convex hull 


# Project Text 
1. Zeichenzählung einfügen 
2. Paper in Vorlesungsfolien (Zotero zitieren in Word)


