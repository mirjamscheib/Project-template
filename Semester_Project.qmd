---
title: "Semester_Project"
format: html
---

# Introduction 
....

# Pre-Processing 
•	Daten anreichern: 
    	Oder einfach mit Segmenten arbeiten? Sessile and moving unterscheiden?
  o	Unterscheidung Regen/kein Regen (Wetterstationen Voronoi)
  o	Uni Zugehörigkeit anreichern? 


## OK - Packages 
```{r}
# clear space 
rm(list=ls())

# load packages 
library("readr")
library("dplyr")
library("ggplot2")
library("sf")
library("terra")
library("tmap")
library("gitcreds")
library("dplyr")
library("SimilarityMeasures")
library("lubridate")
library("plotly")
```

## OK - Load Data 
```{r}
# load all posmo data --------------------------------------- 
posmo1 <- read_delim("posmo_data/steinm05_posmo_2023_04_10_2023_05_15.csv")
posmo2 <- read_delim("posmo_data/scheimir_posmo_2023-01-01T00_00_00+01_00-2023-05-15T23_59_59+02_00.csv")
posmo3 <- read_delim("posmo_data/a77bd18b-2615-4b03-802b-879bf3c93798_2023-01-01T00-00-00_2023-05-13T23-59-59.csv")
posmo4 <- read_delim("posmo_data/posmo - BuJa.csv")
posmo5 <- read_delim("posmo_data/posmo.csv")

# gps1 <- read_delim("posmo_data/gps_bike_walk_train.csv", ";")
```

## OK - Filter data/ create workable dataframe
```{r}
# User anschreiben/umbenennen ---------------------------------------------
# change user_id to names, so that we can read better who is who 
posmo1 <- posmo1 |>  
  mutate(dataset = "posmo1")

posmo2 <- posmo2 |>  
  mutate(dataset = "posmo2")

posmo3 <- posmo3 |>  
  mutate(dataset = "posmo3")

posmo4 <- posmo4 |>  
   mutate(dataset = "posmo4")

posmo5 <- posmo5 |>  
  mutate(dataset = "posmo5")


# transform posmo data into an sf object ----------------------------------
posmo1 <- st_as_sf(posmo1, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

posmo2 <- st_as_sf(posmo2, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

posmo3 <- st_as_sf(posmo3, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

posmo4 <- st_as_sf(posmo4, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

posmo5 <- st_as_sf(posmo5, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

# bind all data together, create a single dataframe -------------------------
posmo <- rbind(posmo1, posmo2, posmo3, posmo4, posmo5)

# Datetime in POSIXct format umwandeln -------------------------------------
# Sonstige Datenformate anpassen bei Bedarf --------------------------------
posmo <- posmo |>
  mutate(datetime = as.POSIXct(datetime))
        # weekday = as.factor(weekday),   # evt nicht nötig die character in factor umzuwandeln
        # transport_mode = as.factor(transport_mode),
         #dataset = as.factor(dataset))
```


## Data consistency overview and removal of inconsistent datasets
```{r}
# add better user_id with information which dataset it is
posmo$user_id |> 
  unique()
#[1] "71da47e1-a7a7-4e3e-a77a-25a99294f52a" "57a21dc5-838a-4d5c-b420-608f49e33430" "a77bd18b-2615-4b03-802b-879bf3c93798"
#[4] "4bcef553-b12c-4d77-9728-097fb8af98d3" "1af6fc8e-273d-4889-894b-5dadadd70a01"
View(posmo)

posmo$USER_ID[posmo$user_id == "71da47e1-a7a7-4e3e-a77a-25a99294f52a"] <- "user1"
posmo$USER_ID[posmo$user_id == "57a21dc5-838a-4d5c-b420-608f49e33430"] <- "user2"
posmo$USER_ID[posmo$user_id == "a77bd18b-2615-4b03-802b-879bf3c93798"] <- "user3"
posmo$USER_ID[posmo$user_id == "4bcef553-b12c-4d77-9728-097fb8af98d3"] <- "user4"
posmo$USER_ID[posmo$user_id == "1af6fc8e-273d-4889-894b-5dadadd70a01"] <- "user5"

#View data consistency
ggplot(posmo, aes(datetime, USER_ID))+
         geom_point()
# -> User4 will be removed!!

posmo <- subset(posmo, dataset != "posmo4") 

#Kontrollieren:
posmo$dataset |> 
  unique()
#posmo4 successfully removed

```

### OK - remove outliers 
Ich habe in den Daten gesehen, dass sogar der Transport mode Airplane drin ist. Diesen habe ich am Schluss hier auch noch entfernt. Ich denke die Begrenzung anhand der schweizer grenze ist aber schon ok sonst :).
```{r}
# delete trajectory data outside of switzerland (= delete outliers; norway & france) ------------------------------------------------------------------
# plot data to look where outliers are 
tmap_mode("view")

# look at single posmo data to determine outliers 
# outlier - norway
tm_shape(posmo1) +
  tm_dots()

# no outlier
tm_shape(posmo2) +
  tm_dots()

# no outlier
tm_shape(posmo3) +
  tm_dots()

# no outlier 
tm_shape(posmo4) +
  tm_dots()

# outlier - france 
tm_shape(posmo5) +
  tm_dots()

# load swiss boundary 
swiss <- read_sf("data/schweiz.gpkg")

# cut layer with swiss boarder
# result_layer <- st_intersection(posmo, swiss)
posmo_cut <- st_intersection(posmo, swiss)

# now outliers are out 
tm_shape(posmo_cut) +
 tm_dots()

# remove transport_mode Airplane because it is part of the outliers and transport speed is far to high 
posmo_cut <- posmo_cut |>
  subset(transport_mode != "Airplane")

# save cleaned dataset in an .csv file 
st_write(posmo_cut, "posmo_data/posmo_cut.csv")
```



## Add convenience variables 
### OK - day/night, weekend/weekday
```{r}
# load cleaned data set ------------------------------------
posmo <- read_delim("posmo_data/posmo_cut.csv")

# create sf object --------------------------------------------------
posmo <- st_as_sf(posmo, coords = c("lon_x","lat_y"), crs = 2056)

# Unterscheidung zwischen Wochentag und Wochenende (Sa-So: Weekend, Mo-Fr: Workday) -----------------------------------------------------------------
posmo <- posmo |>
  mutate(day_week = ifelse(weekday %in% c("Sat", "Sun"), "weekend", "weekday"))

# Unterscheidung Tag, Nacht (Tag: 06:00 – 22:00, Nacht: 22:00 – 06:00?) --------------
# Define the start and end time ranges
start_time <- as.POSIXct("06:00:00", format = "%H:%M:%S", tz = "UTC")
end_time <- as.POSIXct("22:00:00", format = "%H:%M:%S", tz = "UTC")

# Extract only the time component
start_time <- format(start_time, format = "%H:%M:%S")
end_time <- format(end_time, format = "%H:%M:%S")

# create convenience variables day/night -------------------------------------------
posmo <- posmo |>
  mutate(time = format(datetime, format = "%H:%M:%S", tz = "UTC"), # Add convenience variable with only time 
         day_night = ifelse(time >= start_time & time <= end_time, "night", "day"))


# proof if convenience variables worked ------------------------------------
unique(posmo$day_night)
unique(posmo$day_week)

# we need the coordinates in separates columns to calculate eucl. distance
posmo_coordinates <- st_coordinates(posmo)

# add the separated coordinates to the posmo variable 
posmo <- cbind(posmo, posmo_coordinates)

#add date only
posmo <- posmo |> 
  mutate(date = lubridate::date(datetime ))

```

## Cut Dataset in Time
Have an overview of the time span of the different data sets
```{r}
ggplot(posmo, aes(datetime, USER_ID))+
         geom_point()
```


### rain/no rain Nils
Bedeutung Spalten in weather: 
- tre200s0 = Lufttemperatur 2 m über Boden	Momentanwert (°C)
- rco150z0 = Niederschlagsdauer	in Zehnminutensumme (wir brauchen also das, wenn 0 oder NA dann = no_rain)
- sre00z0 = Sonnenscheindauer	Zehnminutensumme

Hier habe ich versucht, dass für jeden Punkt der gemessen wurde in der Trajectory jeweils ausgerechnet wird, welche Wetterstation am nächsten ist & dann für die am nächsten liegende Wetterstation die Regenwerte übernommen werden sollen 
```{r}
# load all weather data --------------------------------------- 
legend <- read_delim("data/weather_legend.csv")
weather_raw <- read_delim("data/weather_measurements.csv") 

# join data together ---------------------------------------------
# left_join() weil wir nur die Informationen haben wollen, für die auch Messwerte vorliegen. Messwerte sind in der Tabelle weather
weather <- left_join(weather_raw, legend, by = "stn")

# create sf object --------------------------------------------------
weather <- st_as_sf(weather, coords = c("E","N"), crs = 2056)

# create a new column to round datetimeUTC for wildboar ------------------
# diesen Abschnitt kann man glaube ich dann ignorieren 
posmo_cut <- posmo_cut |>
  mutate(
    Datetime_round = lubridate::round_date(datetime, "10 minutes")
    )

# create an sf object for legend 
legend_sf <- st_as_sf(legend, coords = c("E","N"), crs = 2056) 

# calculate nearest weather stations from every point 
posmo_cut$stn <- legend_sf$stn[st_nearest_feature(posmo_cut, legend_sf)]


# select only rain data, time and station names from weather 
weather_posmo <- st_drop_geometry(weather) |> 
  select(rco150z0, time, stn) 

# join rain and station name information for every trajectory point which is the nearest to the calulated stations 
posmo_added <- left_join(posmo_cut, weather_posmo, by = c("stn" = "stn", "Datetime_round" = "time"))
```

# Research Questions 
Does the weather condition (e.g. rain, sunshine) impact spatio-temporal patterns of students by foot and/or bicycle?

o	Group by movement (nicht bewegt, bewegt), Tag/Nacht, Datum, Wettercondition, User_id
o	Mittlere Distanz pro Travelmode (wie pro travelmode?)

```{r}
# Mittlere Distanz gesamt ausrechnen (wie geht das pro Tag?) -------------------------
# Convert timestamp to date format
posmo$date <- as.Date(posmo$datetime)


# Create an sf object from the dataframe with the appropriate CRS
posmo_sf <- st_as_sf(posmo, coords = c("X", "Y"), crs = 2056)

# Transform the coordinates to the desired CRS if necessary
posmo_sf_transformed <- st_transform(posmo_sf, crs = "+init=EPSG:2056")

# Calculate distance traveled using the sf package
# BRAUCHT EEEEEEWIG ZUM RECHNEN..... 
posmo_sf_transformed$distance <- c(0, st_distance(posmo_sf_transformed[-1, ], posmo_sf_transformed[-nrow(posmo_sf_transformed), ]))

# Aggregate the distance by date and calculate the mean distance traveled per day
mean_distance_per_day <- aggregate(posmo_sf_transformed$distance, by = list(date = posmo$date), FUN = mean)

# Print the resulting dataframe
print(mean_distance_per_day)



#What transport modes are there?
posmo$transport_mode |> 
  unique()
# [1] NA         "Other1"   "Car"      "Walk"     "Train"    "Tram"     "Bike"     "Run"      "Bus"      "Horse"    "Airplane"
#[12] "E_Bike"

# Mittlere Distanz Fussverkehr ------------------------------------------------
# 1. isolate all rows with travelmode "walk" ----------------------------------
posmo_walk <- posmo |>
  subset(transport_mode == "Walk") #include "Run"?

# Mittlere Distanz Veloverkehr -------------------------------------------------
# 1. isolate all rows with travelmode "bike" ----------------------------------
posmo_bike <- posmo |>
  subset(transport_mode == "Bike")

# Mittlere Distanz ÖV/Auto -------------------------------------------------
# 1. isolate all rows with travelmode "car", "train" ----------------------------------
posmo_car_train <- posmo |>
  subset(transport_mode == c("Train", "Tram", "Car", "Bus"))#works!

#Check for "Horse" and "Run", Frequency? Include/exclude?
  
```

Calculate timelag, steplength and speed for posmo 

In general first:
```{r}
#Timelag 
posmo <- posmo |> 
  mutate(diff_s = as.integer(difftime(lead(datetime), datetime, units == "secs")))
#es gibt diff_s mit 0, die muss man glaube ich entfernen, kann es sein das Posmo z.T. doppelte Einträge erfasst hat?

#Steplength
posmo <- posmo |> 
  mutate(steplength_m = sqrt((X - lead(X))^2 + (Y - lead(Y))^2))

#Steplength per day
mean_stepl_per_weekday <- posmo |>  
  group_by(weekday) |> 
  summarise(mean(steplength_m, na.rm = T))

#But we want mean of travelling distance per weekday... 
mean_travldis_per_date <- posmo |>  
  group_by(weekday, date) |> 
  summarise(travldis_day = mean(steplength_m, na.rm = T)) #da ging was in die Hose, irgendwie ist jeder zweite Eintrag 0 und für einen Wochentag gibt es zwei Daten nacheinander, das macht kein Sinn, aber ich glaube es stimmt trotzdem noch.. 

mean_travldis_per_weekday <- mean_travldis_per_date |> 
  group_by(weekday) |> 
  summarise(travldis_weekday = mean(travldis_day))
#was auch immer die Geometry noch da macht..  


#Speed
posmo <- posmo |> 
  mutate(speed_ms = steplength_m/diff_s)

#Check out histogram for speed frequencies
hist(log10(posmo$speed_ms), 100)

```
Same for posmo subset of "walk"
```{r}
#Timelag 
posmo_walk <- posmo_walk |> 
  mutate(diff_s = as.integer(difftime(lead(datetime), datetime, units == "secs")))
#es gibt diff_s mit 0, die muss man glaube ich entfernen, kann es sein das Posmo z.T. doppelte Einträge erfasst hat?

#Steplength
posmo_walk <- posmo_walk |> 
  mutate(steplength_m = sqrt((X - lead(X))^2 + (Y - lead(Y))^2))

#Steplength per day
mean_stepl_per_weekday <- posmo_walk |>  
  group_by(weekday) |> 
  summarise(mean(steplength_m, na.rm = T))

#But we want mean of travelling distance per weekday... 
mean_travldis_per_date <- posmo_walk |>  
  group_by(weekday, date) |> 
  summarise(travldis_day = mean(steplength_m, na.rm = T)) #da ging was in die Hose, irgendwie ist jeder zweite Eintrag 0 und für einen Wochentag gibt es zwei Daten nacheinander, das macht kein Sinn, aber ich glaube es stimmt trotzdem noch.. 

mean_travldis_per_weekday <- mean_travldis_per_date |> 
  group_by(weekday) |> 
  summarise(travldis_weekday = mean(travldis_day))
 
#die Distanzen pro Tag sind sehr hoch, das finde ich speziell.. stimmt das wirklich? Liegt es daran, dass wir nur wenige Personen haben? Gab es viele Fehlerfassungen der App? 
```




```{r}
### FROM VORLESUNG ------------------------------------------------------
# calculates time taken from each step to the next 
# n_plus2 calculates an offset of 2 time steps
posmo <- posmo |>
  mutate(
    n_plus1 = sqrt((lead(X) - X)^2 + (lead(Y) - Y)^2), # distance to pos +15 minutes
    n_plus2 = sqrt((lead(X, 2) - X)^2 + (lead(Y, 2) - Y)^2), # distance to pos +30 minutes
    n_minus1 = sqrt((lag(X) - X)^2 + (lag(Y) - Y)^2), # distance to pos -30 minutes
    n_minus2 = sqrt((lag(X, 2) - X)^2 + (lag(Y, 2) - Y)^2) # distance to pos -15 minutes
  )

# ungroup() because when we apply when we apply rowwise() each row is a grouped individually which we don't want. 
posmo <- posmo |>
  rowwise()|>
  mutate(
    stepMean = mean(c(n_minus1, n_minus2, n_plus1, n_plus2))
  ) |>
  ungroup()
```

Does the day of the week (weekend vs. workday) have an impact on spatio-temporal movement patterns? 

o	Group by movement (nicht bewegt, bewegt), Tag/Nacht, Datum, Tag, User_id
o	Mittlere Distanz pro Travelmode 

```{r}
# Mittlere Distanz gesamt (weekend or weekday) ausrechnen -------------------------
# Aggregate the distance by date and calculate the mean distance traveled per day of the week
mean_distance_per_day_week <- aggregate(posmo_sf_transformed$distance, by = list(day_week = posmo$day_week), FUN = mean)

# Print the resulting dataframe
print(mean_distance_per_day_week)
```

Do students of different universities (ZHAW or UZH) show different spatio-temporal movement patterns?
```{r}

```

# Visualisations 
Wetterfrage: 
•	Boxplot 
o	pro User und Wettercondition 
o	pro Wettercondition 
o	Pro travel mode 
o	Pro Fussverkehr, Veloverkehr

