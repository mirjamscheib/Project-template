---
title: "Semester_Project"
format: html
---

# Introduction 
....

# Pre-Processing 
•	Daten anreichern: 
    	Oder einfach mit Segmenten arbeiten? Sessile and moving unterscheiden?
  o	Unterscheidung Regen/kein Regen (Wetterstationen Voronoi)
  o	Uni Zugehörigkeit anreichern? 


## OK - Packages 
```{r}
# clear space 
rm(list=ls())

# load packages 
library("readr")
library("dplyr")
library("ggplot2")
library("sf")
library("terra")
library("tmap")
library("gitcreds")
library("dplyr")
library("SimilarityMeasures")
library("lubridate")
library("plotly")

```

## OK - Load Data 
we exclude gps data, because of the inherent different nature of data structure of this dataset, which would make research work more complex
```{r}
# load all posmo data --------------------------------------- 
posmo1 <- read_delim("posmo_data/steinm05_posmo_2023_04_10_2023_05_15.csv")
posmo2 <- read_delim("posmo_data/scheimir_posmo_2023-01-01T00_00_00+01_00-2023-05-15T23_59_59+02_00.csv")
posmo3 <- read_delim("posmo_data/a77bd18b-2615-4b03-802b-879bf3c93798_2023-01-01T00-00-00_2023-05-13T23-59-59.csv")
posmo4 <- read_delim("posmo_data/posmo - BuJa.csv")
posmo5 <- read_delim("posmo_data/posmo.csv")
```

## OK - Filter data/ create workable dataframe
```{r}
# name users for easier data handling 
posmo1 <- posmo1 |>  
  mutate(dataset = "posmo1")

posmo2 <- posmo2 |>  
  mutate(dataset = "posmo2")

posmo3 <- posmo3 |>  
  mutate(dataset = "posmo3")

posmo4 <- posmo4 |>  
   mutate(dataset = "posmo4")

posmo5 <- posmo5 |>  
  mutate(dataset = "posmo5")


# transform posmo data into an sf object 
posmo1 <- st_as_sf(posmo1, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

posmo2 <- st_as_sf(posmo2, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

posmo3 <- st_as_sf(posmo3, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

posmo4 <- st_as_sf(posmo4, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

posmo5 <- st_as_sf(posmo5, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

# bind all data together, create a single dataframe 
posmo <- rbind(posmo1, posmo2, posmo3, posmo4, posmo5)

# remore user_id column, because the column dataset has unique/simple names for every user 
posmo <- posmo |>
  subset(dataset != "posmo4") |>
  select(-user_id)

# transform datetime into POSIXct format 
posmo <- posmo |>
  mutate(datetime = as.POSIXct(datetime))
```


## !!! posmo4 removing?? Data consistency overview and removal of inconsistent datasets
```{r}
# look at data consistency
ggplot(posmo, aes(datetime, dataset))+
         geom_point()

# -> posmo4 will be removed because of inconsistent tracking times? 

# control if posmo4 is removed 
posmo$dataset |> 
  unique()
# -> posmo4 successfully removed
```

### OK - remove outliers 
Ich habe in den Daten gesehen, dass sogar der Transport mode Airplane drin ist. Diesen habe ich am Schluss hier auch noch entfernt. Ich denke die Begrenzung anhand der schweizer grenze ist aber schon ok sonst :).
```{r}
# delete trajectory data outside of switzerland (= delete outliers; norway & france) 
# plot data to look where outliers are 
tmap_mode("view")

# look at single posmo data to determine outliers 
# outlier - norway
tm_shape(posmo1) +
  tm_dots()

# no outlier
tm_shape(posmo2) +
  tm_dots()

# no outlier
tm_shape(posmo3) +
  tm_dots()

# no outlier 
tm_shape(posmo4) +
  tm_dots()

# outlier - france 
tm_shape(posmo5) +
  tm_dots()

# load swiss boundary for intersection 
swiss <- read_sf("data/schweiz.gpkg")

# intersect posmo data with swiss boarder
posmo_cut <- st_intersection(posmo, swiss)

# remove transport_mode "Airplane" because it is part of the outliers and transport speed is far to high 
posmo_cut <- posmo_cut |>
  subset(transport_mode != "Airplane")

# control if outliers are removed 
tm_shape(posmo_cut) +
 tm_dots()

# save cleaned dataset in an .gpkg file to shorten calculation time for subsequent analysing steps 
st_write(posmo_cut, "posmo_data/posmo_cut.gpkg")
```


## OK - Add convenience variables 
### OK - day/night, weekend/weekday
```{r}
# load cleaned data set 
posmo <- read_sf("posmo_data/posmo_cut.gpkg")


# Unterscheidung zwischen Wochentag und Wochenende (Sa-So: Weekend, Mo-Fr: Workday) -----------------------------------------------------------------
posmo <- posmo |>
  mutate(day_week = ifelse(weekday %in% c("Sat", "Sun"), "weekend", "weekday"))

# Unterscheidung Tag, Nacht (Tag: 06:00 – 22:00, Nacht: 22:00 – 06:00?) --------------
# Define the start and end time ranges
start_time <- as.POSIXct("06:00:00", format = "%H:%M:%S", tz = "UTC")
end_time <- as.POSIXct("22:00:00", format = "%H:%M:%S", tz = "UTC")

# Extract only the time component
start_time <- format(start_time, format = "%H:%M:%S")
end_time <- format(end_time, format = "%H:%M:%S")

# create convenience variables day/night -------------------------------------------
posmo <- posmo |>
  mutate(time = format(datetime, format = "%H:%M:%S", tz = "UTC"), # Add convenience variable with only time 
         day_night = ifelse(time >= start_time & time <= end_time, "night", "day"))


# proof if convenience variables worked ------------------------------------
unique(posmo$day_night)
unique(posmo$day_week)

# we need the coordinates in separates columns to calculate eucl. distance
# posmo_coordinates <- st_coordinates(posmo)

# add the separated coordinates to the posmo variable 
# posmo <- cbind(posmo, posmo_coordinates)

#add date only
posmo <- posmo |> 
  mutate(date = lubridate::date(datetime))

```

## !! Cut Dataset in Time
Have an overview of the time span of the different data sets
```{r}
ggplot(posmo, aes(datetime, dataset))+
         geom_point()
```
Cut dataset
```{r}
unique(posmo$date)

posmo_timecut <- posmo |>
  subset(date != c("2023-04-11", "2023-04-12", "2023-04-14", "2023-04-10", "2023-04-13", "2023-04-15", "2023-04-17", "2023-04-20", "2023-04-21", "2023-04-19", "2023-04-01",  "2023-04-02",  "2023-04-03", "2023-04-04", "2023-04-05", "2023-04-06" ,"2023-04-07", "2023-04-08", "2023-04-09", "2023-04-16", "2023-04-18", "2023-05-14"))

unique(posmo_timecut$date)

```

```{r}
ggplot(posmo_timecut, aes(date, dataset))+
         geom_point()
```
Das macht irgendwie keinen Sinn, bitte auch mal anschauen.. 

### OK - rain/no rain Nils
Bedeutung Spalten in weather: 
- tre200s0 = Lufttemperatur 2 m über Boden	Momentanwert (°C)
- rco150z0 = Niederschlagsdauer	in Zehnminutensumme (wir brauchen also das, wenn 0 oder NA dann = no_rain)
- sre00z0 = Sonnenscheindauer	Zehnminutensumme

Hier habe ich versucht, dass für jeden Punkt der gemessen wurde in der Trajectory jeweils ausgerechnet wird, welche Wetterstation am nächsten ist & dann für die am nächsten liegende Wetterstation die Regenwerte übernommen werden sollen 
```{r}
# load all weather data --------------------------------------- 
legend <- read_delim("data/weather_legend.csv")
weather_raw <- read_delim("data/weather_measurements.csv") 

# join data together ---------------------------------------------
# left_join() weil wir nur die Informationen haben wollen, für die auch Messwerte vorliegen. Messwerte sind in der Tabelle weather
weather <- left_join(weather_raw, legend, by = "stn")

# create sf object --------------------------------------------------
weather <- st_as_sf(weather, coords = c("E","N"), crs = 2056)

# create a new column to round datetimeUTC for wildboar ------------------
# diesen Abschnitt kann man glaube ich dann ignorieren 
posmo <- posmo |>
  mutate(
    Datetime_round = lubridate::round_date(datetime, "10 minutes")
    )


# create an sf object for legend 
legend_sf <- st_as_sf(legend, coords = c("E","N"), crs = 2056) 

# calculate nearest weather stations from every point 
posmo$stn <- legend_sf$stn[st_nearest_feature(posmo, legend_sf)]


# select only rain data, time and station names from weather 
weather_posmo <- st_drop_geometry(weather) |> 
  select(rco150z0, time, stn) 

# join rain and station name information for every trajectory point which is the nearest to the calulated stations 
posmo_added <- left_join(posmo, weather_posmo, by = c("stn" = "stn", "Datetime_round" = "time"))

# create convenience variable with rain/no rain for every entry 
posmo_added <- posmo_added |>
  mutate(rain = ifelse(rco150z0 %in% c(0, NA), "no_rain", "rain"))

# we need the coordinates in separates columns to calculate eucl. distance
posmo_coordinates <- st_coordinates(posmo_added)

# add the separated coordinates to the posmo variable 
posmo_sep <- cbind(posmo_added, posmo_coordinates)

# save clean data in dataframe as .gpkg
st_write(posmo_added, "posmo_data/posmo_clean.gpkg")

# save clean data in .csv 
write_csv(posmo_sep, "posmo_data/posmo_clean.csv")
```

# Research Questions 
## Question 1: Miriam 
Does the day of the week (weekend vs. workday) have an impact on spatio-temporal movement patterns?
- spatial: movement pattern -> mean trip duration/distance per weekday/workday - DONE
- temporal: mean distance per weekend-day or workday-day -  DONE
```{r}
# load clean data 
posmo <- read_sf("posmo_data/posmo_clean.gpkg")
# Mittlere Distanz gesamt ausrechnen (wie geht das pro Tag?) -------------------------
# Convert timestamp to date format
posmo$date <- as.Date(posmo$datetime)


# Create an sf object from the dataframe with the appropriate CRS
# posmo_sf <- st_as_sf(posmo, coords = c("X", "Y"), crs = 2056) # nicht nötig, weil schon sf object 

# Transform the coordinates to the desired CRS if necessary
# posmo_sf_transformed <- st_transform(posmo_sf, crs = "+init=EPSG:2056") nicht nötig weil schon transofrmiert 
```

Calculate timelag, steplength and speed for posmo -> temporal

In general first:
```{r}
# load clean data 
posmo <- read_sf("posmo_data/posmo_end1.gpkg")

# we need the coordinates in separates columns to calculate eucl. distance
posmo_coordinates <- st_coordinates(posmo)

# add the separated coordinates to the posmo variable 
posmo <- cbind(posmo, posmo_coordinates)

#Timelag 
posmo <- posmo |> 
  mutate(diff_s = as.integer(difftime(lead(datetime), datetime, units == "secs")))
#es gibt diff_s mit 0, die muss man glaube ich entfernen, kann es sein das Posmo z.T. doppelte Einträge erfasst hat?

#Steplength
posmo <- posmo |> 
  mutate(steplength_m = sqrt((X - lead(X))^2 + (Y - lead(Y))^2))

#Steplength per day
mean_stepl_per_weekday <- posmo |>  
  group_by(weekday, dataset) |> 
  summarise(mean(steplength_m, na.rm = T))

#But we want mean of travelling distance per weekday... 
mean_travldis_per_date <- posmo |>  
  group_by(weekday, date, dataset) |> 
  summarise(travldis_day = mean(steplength_m, na.rm = T)) #da ging was in die Hose, irgendwie ist jeder zweite Eintrag 0 und für einen Wochentag gibt es zwei Daten nacheinander, das macht kein Sinn, aber ich glaube es stimmt trotzdem noch.. 

mean_travldis_per_weekday <- mean_travldis_per_date |> 
  group_by(weekday, dataset) |> 
  summarise(travldis_weekday = mean(travldis_day))
#was auch immer die Geometry noch da macht..  

# visualize mean travelled distance per date
ggplot() +
  geom_boxplot(data = mean_travldis_per_date, aes(dataset, log(travldis_day)), notch = T) +
  labs(title = "mean travelled distance per date")


#Speed
posmo <- posmo |> 
  mutate(speed_ms = steplength_m/diff_s)

#Check out histogram for speed frequencies
hist(log10(posmo$speed_ms), 100)

#Steplength WEEKDAY Influence -------------------------------------
#But we want mean of travelling distance per weekday... 
mean_travldis_per_date_week <- posmo |> 
  mutate(steplength_m = sqrt((X - lead(X))^2 + (Y - lead(Y))^2))|>  
  group_by(day_week, date, dataset) |> 
  summarise(travldis_day = mean(steplength_m, na.rm = T))

# visualize mean travelled distance compared between weekend/weekday
ggplot() +
  geom_boxplot(data = mean_travldis_per_date_week, aes(day_week, log(travldis_day))) +
  labs(title = "mean travelled distance compared between weekend/weekday")

```

Same for posmo subset of "walk"
```{r}
#Timelag 
posmo_walk <- posmo_walk |> 
  mutate(diff_s = as.integer(difftime(lead(datetime), datetime, units == "secs")))
#es gibt diff_s mit 0, die muss man glaube ich entfernen, kann es sein das Posmo z.T. doppelte Einträge erfasst hat?

#Steplength
posmo_walk <- posmo_walk |> 
  mutate(steplength_m = sqrt((X - lead(X))^2 + (Y - lead(Y))^2))

#Steplength per day
mean_stepl_per_weekday <- posmo_walk |>  
  group_by(weekday) |> 
  summarise(mean(steplength_m, na.rm = T))

#But we want mean of travelling distance per weekday... 
mean_travldis_per_date <- posmo_walk |>  
  group_by(weekday, date) |> 
  summarise(travldis_day = mean(steplength_m, na.rm = T)) #da ging was in die Hose, irgendwie ist jeder zweite Eintrag 0 und für einen Wochentag gibt es zwei Daten nacheinander, das macht kein Sinn, aber ich glaube es stimmt trotzdem noch.. 

mean_travldis_per_weekday <- mean_travldis_per_date |> 
  group_by(weekday) |> 
  summarise(travldis_weekday = mean(travldis_day))
 
#die Distanzen pro Tag sind sehr hoch, das finde ich speziell.. stimmt das wirklich? Liegt es daran, dass wir nur wenige Personen haben? Gab es viele Fehlerfassungen der App? 
```

SPATIAL: movement pattern -> mean duration per weekday/workday
```{r}
### Calculate temporal windows ------------------------------------------------------
# calculates time taken from each step to the next 
# n_plus2 calculates an offset of 2 time steps
posmo <- posmo |>
  mutate(
    n_plus1 = sqrt((lead(X) - X)^2 + (lead(Y) - Y)^2), # distance to pos + 10 seconds
    n_plus2 = sqrt((lead(X, 2) - X)^2 + (lead(Y, 2) - Y)^2), # distance to pos +20 seconds
    n_minus1 = sqrt((lag(X) - X)^2 + (lag(Y) - Y)^2), # distance to pos -10 seconds
    n_minus2 = sqrt((lag(X, 2) - X)^2 + (lag(Y, 2) - Y)^2) # distance to pos -20 seconds
  )

# ungroup() because when we apply rowwise() each row is a grouped individually which we don't want. 
posmo <- posmo |>
  rowwise()|>
  mutate(
    stepMean = mean(c(n_minus1, n_minus2, n_plus1, n_plus2))
  ) |>
  ungroup()
```

Define static, than remove "static point"
```{r}
posmo <- posmo |>
    ungroup() |>
    mutate(static = stepMean < mean(stepMean, na.rm = TRUE))

posmo_nostatic <- posmo |>
    filter(!static)

posmo_nostatic |>
    ggplot(aes(X, Y)) +
    geom_path() +
    geom_point() +
    coord_fixed() +
    theme(legend.position = "bottom")

tmap_mode("view")

tm_shape(posmo_nostatic) +
  tm_dots()

```

Segment-based analysis
Asign segmet IDs and use them to remove short segments and calculate segment (trip) duration
```{r}
rle_id <- function(vec) {
    x <- rle(vec)$lengths
    as.factor(rep(seq_along(x), times = x))
}

posmo <- posmo |>
    mutate(segment_id = rle_id(static))

head(posmo)
unique(posmo$segment_id) #wie erwartet haben wir uuunzählige Segmente

```

For mean duration of trips per weekday/weekend-day remove static segments and segments with duration < 5min
```{r}
#only movement segments
posmo_trips <- posmo |>
    filter(!static)
    
#calculate trip duration and trip distance
posmo_trips <- posmo_trips |>
  group_by(segment_id) |> 
  mutate(trip_duration = sum(diff_s), trip_dis = sum(steplength_m))

#remove trips that are shorter than 10min = 600s
posmo_trips <- posmo_trips |>
  subset(trip_duration > 600)

```

Calculate mean duration and mean dis of trips per day
```{r}
#mean trip duration looks odd, need to check that (!!)
posmo_trips |>
  group_by(segment_id) |>
  ggplot() +
  geom_boxplot(aes(day_week, log(trip_duration/60))) +
  labs(title = "mean trip duration [min] compared between weekend/weekday")
  
```


```{r}
#mean trip distance compared between weekend/weekday seems OK
posmo_trips |>
  group_by(segment_id) |>
  ggplot() +
  geom_boxplot(aes(day_week, trip_dis)) +
  labs(title = "mean trip distance compared between weekend/weekday")
  
```

Mean trip distance per hour of the day
```{r} 
posmo_hours <- posmo_trips |>
  mutate(Datetime_round = lubridate::round_date(datetime, "1h")) |>
  mutate(time_round = format(Datetime_round, format = "%H", tz = "UTC")) # Add convenience variable with only time 


posmo_hours |>
  group_by(segment_id) |>
  ggplot() +
  geom_boxplot(aes(time_round, log(trip_dis))) +
  labs(title = "mean trip distance per hour of the day")

#Wir haben zu wenig Daten für so einen Plot scheint es, die Boxplots sehen nicht so "gesund" aus
```

```{r}
posmo_hours |>
  group_by(segment_id) |>
  ggplot() +
  geom_boxplot(aes(time_round, trip_dis)) +
  coord_polar("x") +
  labs(title = "mean trip distance per hour of the day")

#Tja, da niemand in der Nacht nur einmal unterwegs war, haben wir ab 21Uhr bis 04 Uhr Morgens absolut keine Daten...

```

## Question 2: Miriam
Durchschnittliche Reisestrecke pro Tageszeit, gibt es Tageszeiten zu denen man eher längere/kürzere Strecken reist?  
Durchschnittliche Anzahl Reisen pro Tag? 

```{r}
posmo_hours |>
  group_by(segment_id) |>
  ggplot() +
  geom_bar(aes(trip_dis, colour = time_round)) +
  labs(title = "mean trip distance per hour of the day")
```



Lineplot with hours and weekdays, number of trips
```{r}
posmo_hours |>
  group_by(segment_id) |>
  ggplot() +
  geom_line(aes(time_round, trip_dis, colour = weekday)) +
  labs(title = "mean trip distance per hour of the day")

```

Average number of trips per day
```{r}
posmo_hoursx <- posmo_hours |>
  mutate(segment_name = as.character(segment_id)) |> 
  group_by(date, segment_name) |>
  add_count(segment_name)


#num_trips = Anzahl verschiedener segment_ids  pro date
#funktionier aber nicht mit einem Factor, es zählt nicht die Anzahl verschiedenen Factors pro Tag...
?count()

View(posmo_hoursx)

```

Same with mean travel distance (not trip distance) per hours
```{r}
mean_travldis_per_hour <- posmo_hours |> 
  mutate(steplength_m = sqrt((X - lead(X))^2 + (Y - lead(Y))^2))|>  
  group_by(day_week, time_round, weekday) |> 
  summarise(travldis_hour = mean(steplength_m, na.rm = T))



mean_travldis_per_hour |>
  ggplot() +
  geom_boxplot(aes(time_round, travldis_hour, colour = weekday)) +
  labs(title = "mean distance per hour of the day")

#Ich verstehe nicht, was ich da machen muss, dass ich so einen tollen Linienplot erhalte... die Boxplots müssten ja nurnoch mit Linien verbunden sein, aber so eine Funktion gibt es irgendwie nicht
```



Ansatz von Mirj:

- gleicher Plot wie im Best practice example: linienplot mit weekdays (pro weekday 1 linie)
```{r}
# Habe hier schon mal versucht den Plot vom Best Practice example zu erstellen 
# Geht wohl doch nicht so einfach. Meine Vorgehensweise: ich wollte die mittlere Distanz pro stunde am Tag und wochentag ausrechnen damit dann für alle user jeweils der durchschnitt berechnet wird wie gross die tavel-distance zu einer bestimmten stunde ist 
# round datetime to 1h 
posmo_round <- posmo |>
  mutate(Datetime_round = lubridate::round_date(datetime, "1h")) |>
  mutate(time_round = format(Datetime_round, format = "%H", tz = "UTC")) # Add convenience variable with only time 


# ich glaube hier liegt wahrsch der Fehler. Der Datensatz den wir brauchen um den Linienplot zu machen bräuchte folgendes: Für jede volle Stunde für einen ganzen Tag, also 24h (z.B. 8 Uhr, 10 Uhr etc.) muss ein Wert der mittleren Traveldistanz für jeden Wochentag vorliegen. 
# Bsp. für 10 Uhr haben wir dann 5 Einträge (für Mo-Fr je einen) und so weiter für jede Stunde

# Ich habe das Gefühl irgendwie der Datensatz stimmt eig. schon aber checke nicht woran es liegt
posmo_test <- posmo_round |>
  group_by(time_round, weekday) |>
  mutate(steplength = sqrt((X-lead(X))^2+(Y-lead(Y))^2)) |>
  summarise(mean_dis = mean(steplength, na.rm = TRUE))


# im plot sieht es dann aber eben nicht so aus... und ich weiss nicht genau woran es liegt
ggplot(posmo_test, aes(time_round, log(mean_dis), col = weekday)) +
  geom_point()+
  geom_line()

#Wieso funktioniert geom_line nicht? Im Internet steht der Code genauso und es gibt eine Line... 
```


## Question 3: Mirjam 
Does the weather condition (e.g. rain, sunshine) impact spatio-temporal patterns of students by foot and/or bicycle?
- spatial: movement pattern (duration, distance etc. Literatur)
- temporal: mean distance per weekend-day or workday-day
### Temporal Analysis 
Miriam: Du kannst ungefähr die gleichen Sachen machen, allerdings wenn du magst kannst du schon die Plots aussortieren (zumindest bei dir) die wir nicht brauchen und die Plots schön gestalten. Habe in keinem Plot die Titel angepasst, hoffe du verstehst es trotzdem. :) 
```{r}
# load clean data 
posmo <- read_sf("posmo_data/posmo_clean.gpkg")

# we need the coordinates in separates columns to calculate eucl. distance
posmo_coordinates <- st_coordinates(posmo)

# add the separated coordinates to the posmo variable 
posmo <- cbind(posmo, posmo_coordinates)
```

```{r}
# 1. calculate mean travelling distance for rain and no rain --------------
mean_dis_rain <- posmo |> 
  mutate(steplength_m = sqrt((X - lead(X))^2 + (Y - lead(Y))^2))|>  
  group_by(rain, date, dataset) |> 
  summarise(travldis_day = mean(steplength_m, na.rm = T))

# 2. visualise mean travelling distance for rain and no rain ------------
# outliers up to 6000 m 
ggplot() +
  geom_boxplot(data = mean_dis_rain, aes(rain, travldis_day)) +
  labs(title = "mean travelled distance compared between rain/no rain over all travel_modes") +
  ylim(0, 500)


# 3. isolate all rows with travelmode "walk" & "run" ----------------------------------
posmo_walk <- posmo |>
  subset(transport_mode == c("Walk", "Run")) #include "Run"?

# 4. calculate mean travelling distance for rain and no rain --------------
mean_dis_rain_walk <- posmo_walk |> 
  mutate(steplength_m = sqrt((X - lead(X))^2 + (Y - lead(Y))^2))|>  
  group_by(rain, date, dataset) |> 
  summarise(travldis_day = mean(steplength_m, na.rm = T))

# 5. visualise mean travelling distance for rain and no rain ------------
# outliers 
ggplot() +
  geom_boxplot(data = mean_dis_rain_walk, aes(rain, travldis_day)) +
  labs(title = "mean travelled distance compared between rain/no rain over all travel_modes") +
  ylim(0, 500)

# 6. isolate all rows with travelmode "bike" ----------------------------------
posmo_bike <- posmo |>
  subset(transport_mode == "Bike")

# 7. calculate mean travelling distance for rain and no rain --------------
mean_dis_rain_bike <- posmo_bike |> 
  mutate(steplength_m = sqrt((X - lead(X))^2 + (Y - lead(Y))^2))|>  
  group_by(rain, date, dataset) |> 
  summarise(travldis_day = mean(steplength_m, na.rm = T))

# 8. visualise mean travelling distance for rain and no rain ------------
# outliers 
ggplot() +
  geom_boxplot(data = mean_dis_rain_bike, aes(rain, travldis_day)) +
  labs(title = "mean travelled distance compared between rain/no rain over all travel_modes") +
  ylim(0, 500)

# Mittlere Distanz ÖV/Auto -------------------------------------------------
# 9. isolate all rows with travelmode "car", "train" ----------------------------------
posmo_car_train <- posmo |>
  subset(transport_mode == c("Train", "Tram", "Car", "Bus"))#works!

# 10. calculate mean travelling distance for rain and no rain --------------
mean_dis_rain_train <- posmo_car_train |> 
  mutate(steplength_m = sqrt((X - lead(X))^2 + (Y - lead(Y))^2))|>  
  group_by(rain, date, dataset) |> 
  summarise(travldis_day = mean(steplength_m, na.rm = T))

# 11. visualise mean travelling distance for rain and no rain ------------
# outliers 
ggplot() +
  geom_boxplot(data = mean_dis_rain_train, aes(rain, travldis_day)) +
  labs(title = "mean travelled distance compared between rain/no rain over all travel_modes")
```


### Spatial Analysis 
```{r}
# 1. calculate velocity and distance (steplength) overall 
posmo_speed <- posmo |>
  group_by(rain, date, dataset) |>
  mutate(timelag = as.numeric(difftime(lead(datetime), datetime, units = "secs"))) |>
  mutate(steplength = sqrt((X-lead(X))^2+(Y-lead(Y))^2)) |>
  mutate(speed = steplength/timelag)

# 2. visualise 
ggplot() +
  geom_boxplot(data = posmo_speed, aes(rain, speed, fill = transport_mode)) +
  labs(title = "mean travelled distance compared between rain/no rain over all travel_modes") +
  ylim(0, 300)

# 3. subset calculated velocity with only "walk" and "run" values
posmo_speed_walk <- posmo_speed |>
  subset(transport_mode == c("Walk", "Run"))

# 4. visualise 
ggplot() +
  geom_boxplot(data = posmo_speed_walk, aes(rain, speed, fill = dataset)) +
  labs(title = "mean travelled distance compared between rain/no rain over all travel_modes") +
  ylim(0, 25)

# 5. subset calculated velocity with only "bike" values
posmo_speed_bike <- posmo_speed |>
  subset(transport_mode == "Bike")

# 6. visualise 
ggplot() +
  geom_boxplot(data = posmo_speed_bike, aes(rain, speed, fill = dataset)) +
  labs(title = "mean travelled distance compared between rain/no rain over all travel_modes")
```


```{r}
# 2. visualise distance
ggplot() +
  geom_boxplot(data = posmo_speed, aes(rain, steplength, fill = transport_mode)) +
  labs(title = "mean travelled distance compared between rain/no rain over all travel_modes") +
  ylim(0, 300)


# 4. visualise 
ggplot() +
  geom_boxplot(data = posmo_speed_walk, aes(rain, steplength, fill = transport_mode)) +
  labs(title = "mean travelled distance compared between rain/no rain over all travel_modes") +
  ylim(0, 25)


# 6. visualise 
ggplot() +
  geom_boxplot(data = posmo_speed_bike, aes(rain, steplength, fill = transport_mode)) +
  labs(title = "mean travelled distance compared between rain/no rain over all travel_modes") +
  ylim(0, 300)
```

```{r}
# 2. visualise distance
ggplot() +
  geom_boxplot(data = posmo_speed, aes(rain, timelag, fill = transport_mode)) +
  labs(title = "mean travelled distance compared between rain/no rain over all travel_modes") +
  ylim(0, 300)


# 4. visualise 
ggplot() +
  geom_boxplot(data = posmo_speed_walk, aes(rain, timelag, fill = transport_mode)) +
  labs(title = "mean travelled distance compared between rain/no rain over all travel_modes") +
  ylim(0, 25)


# 6. visualise 
ggplot() +
  geom_boxplot(data = posmo_speed_bike, aes(rain, timelag, fill = transport_mode)) +
  labs(title = "mean travelled distance compared between rain/no rain over all travel_modes") +
  ylim(0, 300)
```


```{r}
# round datetime to 1h 
posmo_round <- posmo |>
  mutate(Datetime_round = lubridate::round_date(datetime, "1h")) |>
  mutate(time_round = format(Datetime_round, format = "%H:%M:%S", tz = "UTC")) # Add convenience variable with only time 



posmo_test <- posmo_round |>
  group_by(time_round, dataset, weekday) |>
  mutate(steplength = sqrt((X-lead(X))^2+(Y-lead(Y))^2)) |>
  summarise(mean_dis = mean(steplength, na.rm = TRUE))


ggplot(posmo_test, aes(time_round, mean_dis, col = weekday)) +
  geom_point() +
  geom_line()
```


# Visualisations 
Wetterfrage: 
•	Boxplot 
o	pro User und Wettercondition 
o	pro Wettercondition 
o	Pro travel mode 
o	Pro Fussverkehr, Veloverkehr

