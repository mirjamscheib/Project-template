---
title: "Semester_Project"
format: html
---

# Introduction 
....

# Pre-Processing 
•	Daten anreichern: 
    	Oder einfach mit Segmenten arbeiten? Sessile and moving unterscheiden?
  o	Unterscheidung Regen/kein Regen (Wetterstationen Voronoi)
  o	Uni Zugehörigkeit anreichern? 


## OK - Packages 
```{r}
# clear space 
rm(list=ls())

# load packages 
library("readr")
library("dplyr")
library("ggplot2")
library("sf")
library("terra")
library("tmap")
library("gitcreds")
library("dplyr")
library("SimilarityMeasures")
library("lubridate")
library("plotly")
```

## OK - Load Data 
```{r}
# load all posmo data --------------------------------------- 
posmo1 <- read_delim("posmo_data/steinm05_posmo_2023_04_10_2023_05_15.csv")
posmo2 <- read_delim("posmo_data/scheimir_posmo_2023-01-01T00_00_00+01_00-2023-05-15T23_59_59+02_00.csv")
posmo3 <- read_delim("posmo_data/a77bd18b-2615-4b03-802b-879bf3c93798_2023-01-01T00-00-00_2023-05-13T23-59-59.csv")
posmo4 <- read_delim("posmo_data/posmo - BuJa.csv")
posmo5 <- read_delim("posmo_data/posmo.csv")

# gps1 <- read_delim("posmo_data/gps_bike_walk_train.csv", ";")
```

## OK - Filter data/ create workable dataframe
```{r}
# User anschreiben/umbenennen ---------------------------------------------
# change user_id to names, so that we can read better who is who 
posmo1 <- posmo1 |>  
  mutate(dataset = "posmo1")

posmo2 <- posmo2 |>  
  mutate(dataset = "posmo2")

posmo3 <- posmo3 |>  
  mutate(dataset = "posmo3")

posmo4 <- posmo4 |>  
  mutate(dataset = "posmo4")

posmo5 <- posmo5 |>  
  mutate(dataset = "posmo5")


# transform posmo data into an sf object ----------------------------------
posmo1 <- st_as_sf(posmo1, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

posmo2 <- st_as_sf(posmo2, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

posmo3 <- st_as_sf(posmo3, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

posmo4 <- st_as_sf(posmo4, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

posmo5 <- st_as_sf(posmo5, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

# bind all data together, create a single dataframe -------------------------
posmo <- rbind(posmo1, posmo2, posmo3, posmo4, posmo5)

# Datetime in POSIXct format umwandeln -------------------------------------
# Sonstige Datenformate anpassen bei Bedarf --------------------------------
posmo <- posmo |>
  mutate(datetime = as.POSIXct(datetime))
        # weekday = as.factor(weekday),   # evt nicht nötig die character in factor umzuwandeln
        # transport_mode = as.factor(transport_mode),
         #dataset = as.factor(dataset))
```

### remove outliers 
Ich habe in den Daten gesehen, dass sogar der Transport mode Airplane drin ist. Diesen würden wir noch rausnehmen, falls er noch drin ist. Ich denke die Begrenzung anhand der schweizer grenze ist aber schon ok sonst :).
```{r}
# delete trajectory data outside of switzerland (= delete outliers; norway & france) ------------------------------------------------------------------
# load swiss boundary 
swiss <- read_sf("data/schweiz.gpkg")

# cut layer with swiss boarder
result_layer <- st_intersection(posmo, swiss)

# now outliers are out 
tm_shape(result_layer) +
 tm_dots()
```

```{r}
# plot data to look at areas needed to be covered for weather stations 
tmap_mode("view")

# tm_shape(posmo) +
 # tm_dots()

# look at single posmo data to determine outliers 
# outlier - norway
tm_shape(posmo1) +
  tm_dots()

# no outlier
tm_shape(posmo2) +
  tm_dots()

# no outlier
tm_shape(posmo3) +
  tm_dots()

# no outlier 
tm_shape(posmo4) +
  tm_dots()

# outlier - france 
tm_shape(posmo5) +
  tm_dots()
```


## Add convenience variables 
### OK - day/night, weekend/weekday
```{r}
# Unterscheidung zwischen Wochentag und Wochenende (Sa-So: Weekend, Mo-Fr: Workday) -----------------------------------------------------------------
posmo <- posmo |>
  mutate(day_week = ifelse(weekday %in% c("Sat", "Sun"), "weekend", "weekday"))

# Unterscheidung Tag, Nacht (Tag: 06:00 – 22:00, Nacht: 22:00 – 06:00?) --------------
# Define the start and end time ranges
start_time <- as.POSIXct("06:00:00", format = "%H:%M:%S", tz = "UTC")
end_time <- as.POSIXct("22:00:00", format = "%H:%M:%S", tz = "UTC")

# Extract only the time component
start_time <- format(start_time, format = "%H:%M:%S")
end_time <- format(end_time, format = "%H:%M:%S")

# create convenience variables day/night -------------------------------------------
posmo <- posmo |>
  mutate(time = format(datetime, format = "%H:%M:%S", tz = "UTC"), # Add convenience variable with only time 
         day_night = ifelse(time >= start_time & time <= end_time, "night", "day"))


# proof if convenience variables worked ------------------------------------
unique(posmo$day_night)
unique(posmo$day_week)

# we need the coordinates in separates columns to calculate eucl. distance
posmo_coordinates <- st_coordinates(posmo)

# add the separated coordinates to the posmo variable 
posmo <- cbind(posmo, posmo_coordinates)
```

### rain/no rain Version 1
Bedeutung Spalten in weather: 
- tre200s0 = Lufttemperatur 2 m über Boden	Momentanwert (°C)
- rco150z0 = Niederschlagsdauer	in Zehnminutensumme (wir brauchen also das, wenn 0 oder NA dann = no_rain)
- sre00z0 = Sonnenscheindauer	Zehnminutensumme

Das wäre das Vorgehen mit den Thiessenpolygonen. Ich habe aber noch nicht rausgefunden wie ich den polygonen die Regeninformation zuweisen kann, pro stunde/tag und das dann den Punkten zuweisen. (siehe Version 2, finde ich vielversprechender)
```{r}
# load all weather data --------------------------------------- 
legend <- read_delim("data/weather_legend.csv")
weather <- read_delim("data/weather_measurements.csv") 

# join data together ---------------------------------------------
# left_join() weil wir nur die Informationen haben wollen, für die auch Messwerte vorliegen. Messwerte sind in der Tabelle weather
weather <- left_join(weather, legend, by = "stn")

# create sf object --------------------------------------------------
weather <- st_as_sf(weather, coords = c("E","N"), crs = 2056)

# now do voronoi spaces per day to calculate rain/no rain .... :)
## Aufgabe 3: Dichteverteilung mit Thiessen Polygonen 
# thiessenpolygone erstellen 
thiessenpolygone <- weather |>
  st_union() |>
  st_voronoi()

# mit ausdehnung schweiz zusammenführen
swiss <- st_union(swiss)

thiessenpolygone <- st_cast(thiessenpolygone)

# thiessen polygone auf CH-Ausdehnung zuschneiden
thiessenpolygone_clip <- st_intersection(thiessenpolygone, swiss)

# Visualisierung der Thiessen-Polygone
ggplot() +
  geom_sf(data = swiss) +
  geom_sf(data = thiessenpolygone_clip, fill = NA) +
  theme_void()

# jetzt müsste man die thiessenpolygone in richtige spatial polygons umwandeln (vlt. auch multipolygone) und denen dann die spalte mit den Regeninformationen zuweisen
# die Polygone kann man sowieso machen, die ändern ja nicht über die Zeit. Dann wäre aber noch die Frage, wie wir pro Tag, vlt. auch pro 10min etc. dann die Regenwerte zuweisen können 
# thiessenpolygone als shapefile speichern
st_write(thiessenpolygone_clip, "data/thiessenpolygon.shp")

# shapefile öffnen
weather_polygons <- read_sf("data/thiessenpolygon.shp")

#link results with mesh 
weather_polygons$rco150z0 <- as.numeric(weather$rco150z0)
```

### rain/no rain Version 2 
Hier habe ich versucht, dass für jeden Punkt der gemessen wurde in der Trajectory jeweils ausgerechnet wird, welche Wetterstation am nächsten ist & dann für die am nächsten liegende Wetterstation die Regenwerte übernommen werden sollen 

Hat aber noch nicht geklappt. 
```{r}
# create a new column to round datetimeUTC for wildboar ------------------
posmo1 <- posmo1 |>
  select(-place_name) |>
  mutate(
    Datetime_round = lubridate::round_date(datetime, "15 minutes")
    )


weather <- weather |>
  mutate(
    Datetime_round = lubridate::round_date(time, "15 minutes")
    )


# finds the nearest weather stations for every trajectory point  
# gibt hald ein komischer Output der ja keine Infos zum Regen drin hat 
joined_data <- st_nearest_feature(posmo1, weather)


# hier noch keine Lösung gefunden 
annotated_data <- posmo1 %>%
  st_join(joined_data, by = c("Datetime_round" = "Datetime_round"))
```

### ignore - (Annotate Trajectories from vector data)
Das wäre dann das Vorgehen, wenn wir den Thiessenpolygonen die Regeninformationen zugewiesen haben 
```{r}
# to annotate points of wildboar data with landuse variables
# st_join() is always a left join 
wildschwein_BE <- st_join(wildschwein_BE, fanel)

# overlay the two layers to look where they overlap 
ggplot() +
  # geom_sf(aes(fill = Frucht)) +
  geom_sf(data = wildschwein_BE, alpha = 0.3, pch = ".", aes(col = Frucht)) +
  theme(legend.position = "none") +
  coord_sf(datum = 2056)
```

### ignore - (Annotate Trajectories from raster data)
Das wäre das Vorgehen, wenn wir eine Interpolationsmethode wie IDW verwenden würden & das Resultat der Wetterdaten ein Raster wäre
```{r}
# hier muss das raster zuerst und dann der Punktlayer angegeben werden 
# man kann auch ein buffer anwenden
veg_extract <- extract(veg, wildschwein_BE)

# mit buffer angewendet
veg_extract <- extract(veg, wildschwein_buffer, fun = mean)

str(veg_extract)

# annotate raster results to original dataframe 
wildschwein_BE$veg <- veg_extract$vegetationshoehe_LFI

# overlay the two layers to look where they overlap 
ggplot() +
  # geom_sf(aes(fill = Frucht)) +
  geom_sf(data = wildschwein_BE, alpha = 0.3, pch = ".", aes(col = veg)) +
  theme(legend.position = "none") +
  coord_sf(datum = 2056)
```

# Research Questions 
Does the weather condition (e.g. rain, sunshine) impact spatio-temporal patterns of students by foot and/or bicycle?

o	Group by movement (nicht bewegt, bewegt), Tag/nacht, Datum, Wettercondition, User_id
o	Mittlere Distanz pro Travelmode (wie pro travelmode?)

```{r}
# Mittlere Distanz gesamt ausrechnen (wie geht das pro Tag?) -------------------------
# Convert timestamp to date format
posmo$datetime <- as.Date(posmo$datetime)

# Create an sf object from the dataframe with the appropriate CRS
posmo_sf <- st_as_sf(posmo, coords = c("X", "Y"), crs = 2056)

# Transform the coordinates to the desired CRS if necessary
posmo_sf_transformed <- st_transform(posmo_sf, crs = "+init=EPSG:2056")

# Calculate distance traveled using the sf package
# BRAUCHT EEEEEEWIG ZUM RECHNEN..... 
posmo_sf_transformed$distance <- c(0, st_distance(posmo_sf_transformed[-1, ], posmo_sf_transformed[-nrow(posmo_sf_transformed), ]))

# Aggregate the distance by date and calculate the mean distance traveled per day
mean_distance_per_day <- aggregate(posmo_sf_transformed$distance, by = list(datetime = posmo$datetime), FUN = mean)

# Print the resulting dataframe
print(mean_distance_per_day)


# Mittlere Distanz Fussverkehr ------------------------------------------------
# 1. isolate all rows with travelmode "walk" ----------------------------------
posmo_walk <- posmo |>
  subset(transport_mode == "Walk")

# Mittlere Distanz Veloverkehr -------------------------------------------------
# 1. isolate all rows with travelmode "bike" ----------------------------------
posmo_bike <- posmo |>
  subset(transport_mode == "Bike")
```


```{r}
### FROM VORLESUNG ------------------------------------------------------
# calculates time taken from each step to the next 
# n_plus2 calculates an offset of 2 time steps
posmo <- posmo |>
  mutate(
    n_plus1 = sqrt((lead(X) - X)^2 + (lead(Y) - Y)^2), # distance to pos +15 minutes
    n_plus2 = sqrt((lead(X, 2) - X)^2 + (lead(Y, 2) - Y)^2), # distance to pos +30 minutes
    n_minus1 = sqrt((lag(X) - X)^2 + (lag(Y) - Y)^2), # distance to pos -30 minutes
    n_minus2 = sqrt((lag(X, 2) - X)^2 + (lag(Y, 2) - Y)^2) # distance to pos -15 minutes
  )

# ungroup() because when we apply when we apply rowwise() each row is a grouped individually which we don't want. 
posmo <- posmo |>
  rowwise()|>
  mutate(
    stepMean = mean(c(n_minus1, n_minus2, n_plus1, n_plus2))
  ) |>
  ungroup()
```

Does the day of the week (weekend vs. workday) have an impact on spatio-temporal movement patterns? 

o	Group by movement (nicht bewegt, bewegt), Tag/nacht, Datum, Tag, User_id
o	Mittlere Distanz pro Travelmode 

```{r}
# Mittlere Distanz gesamt (weekend or weekday) ausrechnen -------------------------
# Aggregate the distance by date and calculate the mean distance traveled per day of the week
mean_distance_per_day_week <- aggregate(posmo_sf_transformed$distance, by = list(day_week = posmo$day_week), FUN = mean)

# Print the resulting dataframe
print(mean_distance_per_day_week)
```

Do students of different universities (ZHAW or UZH) show different spatio-temporal movement patterns?
```{r}

```

# Visualisations 
Wetterfrage: 
•	Boxplot 
o	pro User und Wettercondition 
o	pro Wettercondition 
o	Pro travel mode 
o	Pro Fussverkehr, Veloverkehr

